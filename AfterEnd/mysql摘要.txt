*mysql8在安装后intellij或Navicat都连接不上，报错“ The last packet sent successfully to the server was 0 milliseconds ago.”
 后来用telnet连接3306连接不上，于是在服务器开了防火墙和端口，还是不行
 后来又在阿里云服务器【安全组】里开了端口，还是不行
 后来又报错“message from server: "Host '110.87.116.253' is not allowed to connect to this MySQL server". ” 
 于是通过百度用命令update user set host = '%' where user ='root';和flush privileges;设置了允许  即可详见cndn收藏
 如果上一步命令执行错误，可以先将%换成localhost执行成功后，重新进入myql再执行上一步即可。
 有时候执行unpdate命令后还是连接不上3306端口，是因为my.cf里设置了skip-grant-tables造成，删除了重启mysql即可。
 注意：因为安装mysql时没有设置忽略大小写，导致quartz的某些表无法被正确查找到，所以安装mysql时候最好先设置忽略大小写

*常用命令service mysqld start|restart|stop



*sharding-jdbc和mycat的区别
 sharding-jdbc和mycat使用不同的理念，sharding-jdbc目前是基于jdbc驱动，无需额外的proxy，因此也无需关注proxy本身的高可用。
 Mycat 是基于 Proxy，它复写了 MySQL 协议，将 Mycat Server 伪装成一个 MySQL 数据库，而 Sharding-JDBC 是基于 JDBC 接口的扩展，是以 jar 包的形式提供轻量级服务的。

*注意：mysql5.x和8.x的jdbc驱动是不一样的，后者在spring中需要增加时区配置

*select for update的作用是在查询的同时 对数据加锁。根据where条件不同，for update产生的锁分为：行锁、间隙锁、表锁。


*mysql常用的sql函数
 字符串连接：select concat (id, name, score) as 别名 from 表名；
                    select concat ('#',id, name, score) as 别名 from 表名；
 格式化：FORMAT函数，第二参数是小数点的位数，有四舍五入的功能。
             SELECT FORMAT(100000,2);--输出100,000.00
               
*count(*) 和 count(1)和count(col_name) 有什么区别
count(*)=count(1)>count(主键)>count(name)
count(*) 其实统计的就是全表的数据条数，会被sql优化器优化成count(0),如果表中有二级索引的话会优化走二级索引。
count(name) 这个是统计name不为null的记录条数，不会走索引（如果name是主键则有可能优化走二级索引），遍历了所有的记录

*候选键：一种划分键的方式，按照候选键分的话可以分为主键和可选键


*LIKE和REGEXP的区别
 LIKE匹配整个列（like是模糊查询），如果被匹配的文本仅在列值中出现，LIKE并不会找到它，相应的行也不会返回（当然，使用通配符除外）
 REGEXP在列值内进行匹配，如果被匹配的匹配的文本在列值中出现，REGEXP将会找到它，相应的行将被返回，这时一个非常重要的差别（当然，如果适应定位符号^和$，可以实现REGEXP匹配整个列而不是列的子集）
 比如用name like '小红'只能匹配到name==‘小红’的记录
       用name regexp '小红'能匹配到name中所有包含‘小红’’的记录

*MySQL表的5种类型
存储引擎	事务	锁颗粒	主要应用	忌用
MYISAM	不支持	支持并发插入的表级锁	SELECT,INSERT	读写操作频繁
MRG_MYISAM	不支持	支持并发插入的表级锁	分段归档，数据仓库	全局查找过多的场景
Innodb	支持	支持MVCC的行级锁	事务处理	无
Archive	不支持	行级锁	日志记录，只支持insert，select	需要随机，更新，删除
Ndb cluster	支持	行级锁	高可用性	大部分应用

*char_length()和length()函数的区别
 char_length统计字符串的字符长度
 length统计字符串所占字节长度，比如一个emoji符号要占4个字节，但是它的字符长度只有1

*创建FEDERATED类型的表可以连接访问到远程服务器的表。但是在很多查询方面效率比较低，所以比较冷门。
 详见https://www.lanmper.cn/mysql/t8111
 

*查看最大连接数命令 show variables like '%max_connections%';  
  mysql的最大连接数默认是100（mysql5.x版本是151）, 最大可以达到16384。
  不同版本有所差异

=======================分库分表 begin=============================
*演进：
 -传统单库单表出现问题：
  1、数据库连接数限制（一般mysql默认最大连接数100左右，最高可设置1600左右）
  2、表数据量大（单表记录数取决于你的操作系统对单个文件的限制，业界流传500万，超过就要分表分库。可能你入200万速度就很低了，所以... ）
  3、硬件资源（单库单表的qps和tps都会受限制）

 - 传统解决方案：
  读写分离：涉及到数据同步、主从复制
  分库分表：分为垂直分库和水平分库（还有一种垂直拆分表，比如文章表被拆成基础信息表和富文本表）。
      基于代理：在中间代理服务处理。 性能没有jdbc方式高，但是屏蔽了分库细节，开发人员使用简单。还跨语言（支持异构语言系统）
                       Mycat 开源中间件
                       TDSQL 腾讯云的分布式数据库（详见TDSQL MySQL版文档 https://cloud.tencent.com/document/product/557/7700）
      基于JDBC:   属于jdbc直连，在应用层来处理。性能比代理方式高，但是要自己配置分片规则等。只能单一的java语言用
                       Sharedingsphere
       
  双写：在数据增删改查的时候  发给kafka 同步到es，用es去做查询

*分库分表解决方案-Mycat
 主要配置4个xml
  schema.xml逻辑库表配置，主要是逻辑库表和实际物理库表的映射关系
  server.xml启动参数配置
  rule.xml拆分规则配置，主要是数据分片规则（连续分片、离散分片、综合类分片）
  wrapper.conf JVM内核调整配置

*分库分表解决方案-ShardingSphere
 详见csdn收藏《ShardingSphere介绍与使用》、bilibli尚硅谷收藏视频（对应笔记https://segmentfault.com/a/1190000038241298）

*分库分表带来的问题：
 联表分页查询（join查询）
 多库分布式事务
 分布式全局id
 增加开发成本
？Sharedingsphere如何解决上述问题

*垂直分库和水平分库的优缺点（分库可以突破实例并发和吞吐量，分表可以突破500万限制）
 垂直分库：优点：按业务切分，结构清晰，利于维护。
                 缺点：单表数据量大则读写压力依然大，如单表数据量小则资源浪费。
                           不同业务表不能联表查询（甚至分页查询）
 水平分库：优点：数据分布在不同表或不同库，提高了curd的性能和吞吐量。
                 缺点：扩容时（比如增加一个分片库）会涉及比较复杂的数据迁移。
                          分片事务很难处理，比如要更新一定条件范围的数据，而这个数据范围涉及到多个跨库的分片

*最佳实践
 一般我们进行分库分表时，可以根据业务进行垂直分库，垂直分表，水平分库水平分表
 垂直分库：比如用户订单，用户表尽量落到一个表中，和其它不相关的表分开落到不同库里
 垂直分表：比如将用户表拆分为基本信息表（id、name、password）+附加信息表（nick、age....），这样请求频繁的登录操作就只操作基本信息表
 水平分库和水平分表：主要是根据表的数据量进行，如果前期量小可以在单表上，后期如果量大，要用代码写规则做数据迁移。如果用hash一致算法做的数据落位，那么涉及数据迁移的数据量会比较少。
 注意：1、分库分表第一步是确定用什么列（即sharding column），什么规则来分。如前台用户访问较为频繁的就以userId分，如管理后台访问较多则用adminId。这个是根据我们业务场景来确定的。
          2、水平分表目的是突破单表500万限制，但是在一个业务领域的业务表尽量落到一个库中，避免join查询问题性能。
          3、ES双写场景：
                 场景：如果避免不了分库join，一般进行kafka异步双写ES（同步问题多，性能，数据丢失...），用ES进行查询。但是避免不了延迟问题，只能保证最终一致性。如一些查询条件是不包含sharding column的，不可能为了这些请求量并不高的查询再做冗余分库分表。总之复杂的查询就用此方案。
                 PS：多sharding column不到万不得已的情况下最好不要使用，建议采用单sharding column + es的模式简化架构。
                 大致过程：

          4、有时候我们还可以做一些字段的冗余，以减少关联查询。
          5、

*Mysql同步到ES，数据从Mysql同步到ES主要涉及到几个技术关键点
 1.Binlog机制
 2.Canal中间件
 3.Kakfa中间件



 
=======================分库分表 end==============================