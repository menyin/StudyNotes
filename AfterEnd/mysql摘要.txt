*mysql8在安装后intellij或Navicat都连接不上，报错“ The last packet sent successfully to the server was 0 milliseconds ago.”
 后来用telnet连接3306连接不上，于是在服务器开了防火墙和端口，还是不行
 后来又在阿里云服务器【安全组】里开了端口，还是不行
 后来又报错“message from server: "Host '110.87.116.253' is not allowed to connect to this MySQL server". ” 
 于是通过百度用命令update user set host = '%' where user ='root';和flush privileges;设置了允许  即可详见cndn收藏
 如果上一步命令执行错误，可以先将%换成localhost执行成功后，重新进入myql再执行上一步即可。
 有时候执行unpdate命令后还是连接不上3306端口，是因为my.cf里设置了skip-grant-tables造成，删除了重启mysql即可。
 注意：因为安装mysql时没有设置忽略大小写，导致quartz的某些表无法被正确查找到，所以安装mysql时候最好先设置忽略大小写

*常用命令service mysqld start|restart|stop



*sharding-jdbc和mycat的区别
 sharding-jdbc和mycat使用不同的理念，sharding-jdbc目前是基于jdbc驱动，无需额外的proxy，因此也无需关注proxy本身的高可用。
 Mycat 是基于 Proxy，它复写了 MySQL 协议，将 Mycat Server 伪装成一个 MySQL 数据库，而 Sharding-JDBC 是基于 JDBC 接口的扩展，是以 jar 包的形式提供轻量级服务的。

*注意：mysql5.x和8.x的jdbc驱动是不一样的，后者在spring中需要增加时区配置

*select for update的作用是在查询的同时 对数据加锁。根据where条件不同，for update产生的锁分为：行锁、间隙锁、表锁。


*mysql常用的sql函数
 字符串连接：select concat (id, name, score) as 别名 from 表名；
                    select concat ('#',id, name, score) as 别名 from 表名；
 格式化：FORMAT函数，第二参数是小数点的位数，有四舍五入的功能。
             SELECT FORMAT(100000,2);--输出100,000.00
               
*count(*) 和 count(1)和count(col_name) 有什么区别
count(*)=count(1)>count(主键)>count(name)
count(*) 其实统计的就是全表的数据条数，会被sql优化器优化成count(0),如果表中有二级索引的话会优化走二级索引。
count(name) 这个是统计name不为null的记录条数，不会走索引（如果name是主键则有可能优化走二级索引），遍历了所有的记录

*候选键：一种划分键的方式，按照候选键分的话可以分为主键和可选键


*LIKE和REGEXP的区别
 LIKE匹配整个列（like是模糊查询），如果被匹配的文本仅在列值中出现，LIKE并不会找到它，相应的行也不会返回（当然，使用通配符除外）
 REGEXP在列值内进行匹配，如果被匹配的匹配的文本在列值中出现，REGEXP将会找到它，相应的行将被返回，这时一个非常重要的差别（当然，如果适应定位符号^和$，可以实现REGEXP匹配整个列而不是列的子集）
 比如用name like '小红'只能匹配到name==‘小红’的记录
       用name regexp '小红'能匹配到name中所有包含‘小红’’的记录

*MySQL表的5种类型
存储引擎	事务	锁颗粒	主要应用	忌用
MYISAM	不支持	支持并发插入的表级锁	SELECT,INSERT	读写操作频繁
MRG_MYISAM	不支持	支持并发插入的表级锁	分段归档，数据仓库	全局查找过多的场景
Innodb	支持	支持MVCC的行级锁	事务处理	无
Archive	不支持	行级锁	日志记录，只支持insert，select	需要随机，更新，删除
Ndb cluster	支持	行级锁	高可用性	大部分应用

*char_length()和length()函数的区别
 char_length统计字符串的字符长度
 length统计字符串所占字节长度，比如一个emoji符号要占4个字节，但是它的字符长度只有1

*创建FEDERATED类型的表可以连接访问到远程服务器的表。但是在很多查询方面效率比较低，所以比较冷门。
 详见https://www.lanmper.cn/mysql/t8111
 

*查看最大连接数命令 show variables like '%max_connections%';  
  mysql的最大连接数默认是100（mysql5.x版本是151）, 最大可以达到16384。
  不同版本有所差异

=======================分库分表 begin=============================
**阿里建议**
预估数据量：3年内单表数据量大于500w或单数据文件大于2G才考虑分库分表
预估数据趋势：像订单这类持续高速增长的数据今早考虑分库分表，并预留空间。像用户表后期会放缓增长则可以延期考虑分库分表
预估应用场景：频繁变更字段不宜作为分片键，不适合做分库分表。会涉及数据迁移
预估业务复杂度：业务逻辑和分片逻辑绑定会给sql执行带来很多限制，所以如查询逻辑变化非常大，不建议分表分库。 

*分库分表的核心是sql语句，即在增删改查过程中，如何根据分片算法对sql语句进行解析或路由。



*演进：
 -传统单库单表出现问题：
  1、数据库连接数限制（一般mysql默认最大连接数100左右，最高可设置1600左右）
  2、表数据量大（单表记录数取决于你的操作系统对单个文件的限制，业界流传500万，超过就要分表分库。可能你入200万速度就很低了，所以... ）
  3、硬件资源（单库单表的qps和tps都会受限制）

 - 传统解决方案：
  读写分离：涉及到数据同步、主从复制
  分库分表：分为垂直分库和水平分库（还有一种垂直拆分表，比如文章表被拆成基础信息表和富文本表）。
      基于代理：在中间代理服务处理。 性能没有jdbc方式高，但是屏蔽了分库细节，开发人员使用简单。还跨语言（支持异构语言系统）
                       Mycat 开源中间件
                       TDSQL 腾讯云的分布式数据库（详见TDSQL MySQL版文档 https://cloud.tencent.com/document/product/557/7700）
      基于JDBC:   属于jdbc直连，在应用层来处理。性能比代理方式高，但是要自己配置分片规则等。只能单一的java语言用Sharedingsphere
                  从yaml配置spring.shardingsphere.datasource里也可以看出：它的数据源是shardingsphere的特定数据源
       
  双写：在数据增删改查的时候  发给kafka 同步到es，用es去做查询

*分库分表产生的问题：
？分布式主键问题：
？分布式事务问题
？SQL路由：sql分发到哪个节点执行？原封不动的转发吗？ 
？结果合并、零散数据合并问题：每个节点只包含部分结果，如何合并？ 如查询收入前十的用户，那么就得从多个分片分别查询前十再汇总合并。

*分库分表解决方案-Mycat
 主要配置4个xml
  schema.xml逻辑库表配置，主要是逻辑库表和实际物理库表的映射关系
  server.xml启动参数配置
  rule.xml拆分规则配置，主要是数据分片规则（连续分片、离散分片、综合类分片）
  wrapper.conf JVM内核调整配置

*分库分表解决方案-ShardingSphere
 详见csdn收藏《ShardingSphere介绍与使用》、bilibli尚硅谷收藏视频（对应笔记https://segmentfault.com/a/1190000038241298）

*分库分表带来的问题：
 联表分页查询（join查询）
 多库分布式事务
 分布式全局id
 增加开发成本
？Sharedingsphere如何解决上述问题

*垂直分库和水平分库的优缺点（分库可以突破实例并发和吞吐量，分表可以突破500万限制）
 垂直分库：优点：按业务切分，结构清晰，利于维护。
                 缺点：单表数据量大则读写压力依然大，如单表数据量小则资源浪费。
                           不同业务表不能联表查询（甚至分页查询）
 水平分库：优点：数据分布在不同表或不同库，提高了curd的性能和吞吐量。
                 缺点：扩容时（比如增加一个分片库）会涉及比较复杂的数据迁移。
                          分片事务很难处理，比如要更新一定条件范围的数据，而这个数据范围涉及到多个跨库的分片

*最佳实践
 一般我们进行分库分表时，可以根据业务进行垂直分库，垂直分表，水平分库水平分表
 垂直分库：比如用户订单，用户表尽量落到一个表中，和其它不相关的表分开落到不同库里
 垂直分表：比如将用户表拆分为基本信息表（id、name、password）+附加信息表（nick、age....），这样请求频繁的登录操作就只操作基本信息表
 水平分库和水平分表：主要是根据表的数据量进行，如果前期量小可以在单表上，后期如果量大，要用代码写规则做数据迁移。如果用hash一致算法做的数据落位，那么涉及数据迁移的数据量会比较少。
 注意：1、分库分表第一步是确定用什么列（即sharding column），什么规则来分。如前台用户访问较为频繁的就以userId分，如管理后台访问较多则用adminId。这个是根据我们业务场景来确定的。
          2、水平分表目的是突破单表500万限制，但是在一个业务领域的业务表尽量落到一个库中，避免join查询问题性能。
          3、ES双写场景：
                 场景：如果避免不了分库join，一般进行kafka异步双写ES（同步问题多，性能，数据丢失...），用ES进行查询。但是避免不了延迟问题，只能保证最终一致性。如一些查询条件是不包含sharding column的，不可能为了这些请求量并不高的查询再做冗余分库分表。总之复杂的查询就用此方案。
                 PS：多sharding column不到万不得已的情况下最好不要使用，建议采用单sharding column + es的模式简化架构。
                 大致过程：

          4、有时候我们还可以做一些字段的冗余，以减少关联查询。
          5、

*Mysql同步到ES，数据从Mysql同步到ES主要涉及到几个技术关键点
 1.Binlog机制
 2.Canal中间件
 3.Kakfa中间件


*ShardingSphere相关核心概念：
 *真实表：如果订单表分为t_order_0、t_order_1、....这些表就叫真实表

 *逻辑表：与真实表相对，t_order则为逻辑表

 *数据节点：数据分片的最小单元。由数据源名称和数据表组成，例：ds_0.t_order_0。

 *绑定表：​ 指分片规则一致的主表和子表。例如：t_order表和t_order_item表，均按照order_id分片，则此两张表互为绑定表关系。绑定表之间的多表关联查询不会出现笛卡尔积关联，关联查询效率将大大提升。
           简单的说就是t_order_item_0和t_order_0是相关联的，它们才有相互关联的数据，而t_order_item_0和t_order_1是不关联的，没有相关数据。所以查询的时候，不会去关联查询t_order_item_0和t_order_1
           要求：1、两个表的分片策略和算法要一致；2、配置相关联

 *广播表：？？？

 *分片键：用于分片的数据库字段，是将数据库(表)水平拆分的关键字段。例：将订单表中的订单主键的尾数取模分片，则订单主键为分片字段。

 *分片算法：目前提供4种分片算法？？和分片策略不同

 *分片策略：包含分片键和分片算法，由于分片算法的独立性，将其独立抽离。真正可用于分片操作的是分片键 + 分片算法，也就是分片策略。目前提供5种分片策略。

*ShardingSphere相关配置：
 spring.shardingsphere.props.sql.show=true  可以打印出执行的sql。 这里分为Logic SQL（逻辑上的sql）和Actual SQL（真实执行的sql）
 
*分片策略： 
  实际上分片策略不仅仅是负责将数据按规则存储到对应分片中，更重要的是在查询的时候快速定位到数据所在分片
  所以在不同的查询sql语句中，shardingsphere需要根据分片规则对sql语句进行改造，让它能够找到对应的数据分片，提升性能。
  详见blogs《sharding-jdbc 分库分表的 4种分片策略，还蛮简单的》          
 
 *Inline策略:  根据单一分片建进行精确分片
  当业务上使用分片键作为查询条件进行精确查询数据时，Shardingsphere会先精确的查找对应的数据分片，然后再去查找。
  注意：要求此时这个分片建的值要能够通过分片的策略算法计算出对应的分片
        在in（1,2,3）查询中，实际上Inline策略判断不出数据是不是在同一个分片，所以会全分片查找，这也可能导致性能下降。
  如：select * from user where userId=123。 则Shardingsphere会先根据之前分片规则去计算userId=123是放置在哪个分片，先找到分片再查询。而并不会到所有分片上去查询。
      具体效果，可以查看输出的LogicSQL和ActualSQL

 *标准策略： 根据单一分片建进行精确或者范围分片
  如果使用Inline策略，此时对分片键进行between查询，则会报错。 如：wrapper.between("userId",123,456);...
  所以就不能用Inline策略，而使用标准策略。 就能支持范围查询了。
  此时，分片策略规则就不能使用Groovy表达式（如t_user$->{0..1}）,而要指定相应的分配策略类，包含精确查询的类和范围查询的类（也会区分分库的算法类和分表的算法类）
  如果是like查询类型，一般在这种大数据是不太使用的。 性能不高。所以就不考虑了
  总体原理：执行sql语句（可能是查询或增删改），根据配置的分片策略计算出对应的库及表名称，进行sql重新构造，使得根据分片策略规则到指定的库和表操作。 
  包含两种分片算法：精确分片算法和范围分片算法
                    精准分片算法：根据分片键的值计算具体的分库或分表的分片名称（根据配置的是分库的还是分表的策略，原理一致），算法类的doSharding方法返回单一的String类型
                    范围分片算法：根据分片键的范围计算具体的分库或分表的分片名称集合（根据配置的是分库的还是分表的策略，原理一致），算法类的doSharding方法返回多个的String集合类型
                    
  
 *complex策略： 根据多个分片键进行精确或范围分片
 Inline和标准策略都是单一分片键，而complex策略是多分片键策略
 相比上两种分片策略，complex策略原理是一样的，只是分片键由一变多。 

 *Hint策略： 使用自定义的方式进行分片，特点是分片键或者分库的键值可以通过HintManager工具类进行灵活自定义设置，无需在配置文件中写死。
  注意：在调用 SQL 前通过 HintManager 指定分库、分表信息。由于每次添加的规则都放在 ThreadLocal 内，所以要先执行 clear() 清除掉上一次的规则！
  在具体的策略类代码doSharding方法中也能拿到HintManager设置的分片键。
 
 注意：如select * from user where CAST(userId as char) ='12345' 类似这种sql，shardingsphere是很难找出分片键userId的
       也就是我们涉及分表分库的表的查询不能太复杂，否则shardingsphere很难去理解语义并进行sql的重写。
       再如：select * from db2.t_user;//会直接忽略db2进行SQL重写，如  select * from t_user2;
       再如：select * from t_user union all select * from t_user;//看后面一个t_user则不会重写了
       再如：select max(cid) from t_user group by user_id having userId='123'; //这个也会报错

 总之：分库分表的分片策略的核心在于sql，只有能被shardingsphere识别重写的sql才能做分片策略的可能

*具体扩展学习详见bili《B站最牛的Mysql分库分表教程（2022最新版）》
*新版本的shardingsphere新增分片规则
 Sharding By Mod 可以设置取模的数量n，然后进行分片
 Sharding By Datetime 可以根据时间范围进行分片，相当于根据时间归档
 
*shardingsphere暴露了很多spi扩展供开发者实现更多的扩展。 如主键生成策略就可以通过其spi规定进行自定义编写

*时间范围分片和取模分片
 时间范围分片：按时间进行归档，但是容易造成数据倾斜（分片上数据有多有少），查找的时候可能要全分片查找，可能造成性能瓶颈
 取模分片：在分片扩展的时候要进行数据迁移。  此问题也会引出hash一致性算法。
 也可以结合两种分片，如订单先按时间范围分片再按取模分片，如10月、11月，10月份订单量少，所以设定取模2，而11月份订单量大设定取模5，这样就可以通过不同月份不同取模来优化数据分片

*基因法多分片查询 
 场景：用户表通常我们用userId作为分片键，但是在登录或查询用户时往往是使用userName来查询。 这时候如不能进行分片算法计算，则会全分片去查询所有分片用户表。
 解决：将userName进行hash得到的数字hashCode+userId进行改造，作为分片键。  hashCode可以截取后面部分数字，因为如果分片数量只有8，则这个hashCode只需要大于8的数即可取模
       如果把hashCode看作二进制的数，则相当于只需要取后3位，然后将后3位的数字和userId进行融合，组合成一个新的分片键字段（比如叫fenpianKey）则fenpianKey
       注意：用户名是固定不能更改的，否则会出现问题。
？构造使用场景：
  用户表：采用上述基因法多分片查询。
  职位表：
  简历表：

*uuid是字符串主键排序性能低。
 mysql要对主键进行排序，排成一颗B+树。
 我们希望的主键是能单调递增或递减的。才能好排序成B+树

=======================分库分表 end==============================