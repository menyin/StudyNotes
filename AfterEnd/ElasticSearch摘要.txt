*基本学习：
 学习bilibili尚硅谷教学视频，学习笔记详见csdn《Elasticsearch学习笔记》https://blog.csdn.net/u011863024/article/details/115721328
 文档看美特《elasticsearch深入查询.doc》
 中文文档https://docs.kilvn.com/elasticsearch/

*面试题详见csdn收藏《30道你不得不会的Elasticsearch面试题【附答案解析】》

*ES 从存到查的过程：
 0、（此步骤非必须，即静态映射）开发者可通过api去创建文档类型指定文档结构，比如指定name字段的索引分词器和搜索字段分词器
 1、开发者通过api将数据存储，存储时ES会对字符串进行分词创建倒排索引（用到索引分词器）。
 2、开发者通过api进行查询，此阶段会根据搜索分词器进行分词，然后查找。

*ES和Solr的区别是什么？
 es和solr都是基于lucence框架的分词技术的倒排索引进行实现的高性能的搜索引擎框架。
 当单纯的对已有的数据进行检索的话，Solr的性能优于es。
 当实时建立索引的时候，Solr会进行io阻塞，查询性能较差，而es不会。
 随着数据量的增加，Solr的搜索效率变低，而es没有太多变化。
 Solr需要运行在web服务器上，如tomcat，我们需要配置tomcat和Solr的连接，因为Solr本质上就是一个动态的web项目。
 Solr利用Zookeeper进行分布式管理，而es自身带有分布式系统管理功能。
 Solr支持更多的数据结构，如xml，json，而es仅仅支持json格式。
 Solr官方提供的功能更多，而es如果想要更多功能得去安装第三方插件。

*ES7.8需要JDK1.8+    安装前记得查询下对应jdk版本要求
 我本地jdk1.8 下载了window版的ES8不能正常启动

*ES是Restfull风格的接口，响应是json
 常用的api
 http://127.0.0.1:9200/?pretty 查询ES是否启动成功
 http://127.0.0.1:58504/shopping 通过get、delete等方法进行相关索引（类比数据库）操作
 http://127.0.0.1:58504/shopping/_doc 通过post提交json格式的数据，表示提交一条记录即一个document，会返回_id。
                                                           通过get可以查询到这个_doc下的所有记录
 http://127.0.0.1:58504/shopping/_doc/1001 通过post提交json格式的数据，表示提交一条记录即一个document。会返回_id是1001，即自定义id
 查询条件一般在请求体里提交，类似jeecg查询参数，具有一定结构。如：
 {
    'query': {
        'match': {
            'name': 'Tom'
        }
    }
 }x
*条件查询语言Query DSL，和jeecg的条件构造器生成的查询json差不多一个概念
 "_source":["title"]     规定返回文档只有title属性

  "from": 10,       规定第10页

  "size": 10          规定页容量10条

  "sort":{
            "price":{"order":"desc"}  规定按price属性降序
           }

  "bool":{
	"must":[{"match":{"category":"小米"}},{"match":{"price":3999.00}}] 多条件与运算查询（should相当于数据库的||）
	}

 "match"是全文检索（如搜索“小华”，则可能拆成“小”和“华”分别进行搜索），而"match_phrase"是完全匹配，不会拆词。

*在Kibana上常用查询语句：
GET /_cat/indices?v  //查询所有索引信息

POST kibana_sample_data_flights/_count  //查询kibana_sample_data_flights索引的总文档数

GET kibana_sample_data_flights/_mapping //查询kibana_sample_data_flights索引的文档结构

POST kibana_sample_data_flights/_search //查询kibana_sample_data_flights索引的文档

GET kibana_sample_data_flights/_search  //带参数查询kibana_sample_data_flights索引的文档
{
	"aggs":{
		"DestCountry_group":{
			"terms":{
				"field":"DestCountry"
			}
		}
	},
    "size":0
}

 
*ES查询可以做普通的条件查询、范围查询、排序、分页、聚合查询等
 还可以定义我们数据记录json的属性的类型，有的类型可以被分词有的类型不行，使得查询改属性时候去确定是否分词。
 如果将我们数据记录json的tel属性的类型定义为index:false，即不能索引，则说明不能通过tel进行查询。


******** ES的mapping配置相关 begin ********
*ES的mapping配置相关：
  类型配置：
  keyword：不会被分词产生倒排索引，用于结构化内容，如id、电子邮件地址、主机名、状态码、邮政编码或标签。
  text：会被分词产生倒排索引，用于需要进行分词搜索的字段。 该类型字段不能作为排序、聚合
  integer：byte、short、、long、float、double、unsigned_long、half_float、scaled_float等数值类型类似。内部使用long存储浮点数，并且存储一个缩放系数。
  date：ES内部存储的是json，而JSON没有日期类型，所以日期类型数据再ES内部存储的是日期格式化的字符串或毫秒数或秒数，
            可以指定格式format参数，如"format": "yyyy-MM-dd HH:mm:ss||yyyy-MM-dd||epoch_millis"，则当ES底层将毫秒数转为字符串时会依次匹配这三种格式（用||分开）
  boolean：布尔字段接受JSON的true和false值，但也可以接受被解释为true或false的字符串，如false, “false”, “” (空字符串)都会被认为是false，而true, “true”都会被认为是true
  object：不需要和上述类型一样显式地将字段类型设置为object，配置mapping网上查下就知道。  其内部存储实际是扁平化存储，类似"user.address.city":  "泉州"
  nested：和object都是用于存储对象，object在查询嵌套对象时会有一些问题（因为是扁平化存储）。nested正常存储，所以要进行一些限制设置来防止性能问题。
  注意：能否对mapping设置进行修改呢？
           1、已有字段有数据就不支持字段定义修改。如果一定要修改就必须重建索引（Reindex）
           2、新增字段（没有数据），分几种情况：
                Dynamic设置为true时，如果有新增字段的文档写入，Mapping会更新，相应的对新增字段定义类型。
                Dynamic设置为false，Mapping不会被更新，并且新增字段的数据无法被索引，但是，信息会出现在_source中。
                Dynamic设置为Strict，文档会写入失败！
           
？子类型是什么 
？mapping中的store配置是什么

 *索引配置
   在字段配置上，控制倒排索引记录的内容。记录的内容越多，所占用的存储空间就越大。类似Mysql的B+树叶子节点记录了数据的id主键。
   有几种类型docs（记录doc id）、freqs（记录doc id +（term出现频率）term frequencies）、positions （默认）、offsets.......
 *Null Value配置
  在keyword类型字段上配置，用于当字段值为null时，有一个替代值（如“N”）使得在搜索时可以被搜索得到。
 *数组
  ES中不提供专门的数组类型。任何字段都可以包含多个相同字段的数据
 *_source的disabled原理及配置详见下述部分

*************** _source和store相关配置的理解  begin ***************

*_source和store原理详见blogs《elasticsearch中mapping的_source和store的笔记 》、csdn《【Elasticsearch】Elasticsearch 理解mapping中的store属性》《elasticsearch mapping之store》

*_source和store相关配置的理解：
  1、_source是对整个索引级别的配置(默认enable)，store是对字段级别的配置（默认false）
  2、当一个文档（title、date、content）保存到ES时，首先根据分词器将各个字段拆分成词汇（如title拆分为title0、title1...），生成倒排索引。
  3、当索引创建时_source设置enabled=true时，在2步骤存储文档生成倒排索引时也会保存文档全部字段原始值（这些原始值是根据client类解析的“_source JSON”）。当然_source设置enabled=false则不存“_source JSON”
  4、当字段上store设置true，在2步骤存储文档生成倒排索引时还会在将该字段另外存储一份到“独立存储”，并且“独立存储”在检索时是性能比_source JSON高的。
  5、在搜索时：
            正常搜索时，则会通过倒排索引找到文档Id，然后根据id找到“_source JSON”里所有原始字段值并返回给客户端
            传 "_source": ["title"]参数搜索时，则从“_source JSON”取出title字段值返回。
            传"stored_fields": ["title"]参数搜索时，则会从“独立存储”取出title字段值返回。
  6、为什么要用“store独立存储”再存储一次，增加了存储和检索时的IO，有什么好处？ 因为在某些场景下需要提高性能。 以下是最佳实践。
            场景：当文档中content字段值内容比较多，我们只想让content生成倒排索引，而并不像存储它的原始值（检索结果用不到）。 而title和date字段的原始值又必须作为检索结果返回给客户端。
            解决：首先，我们可以整个索引级别设置_source的enable=false，则ES便不会将文档所有字段原始值存在“_source JSON”。
                     其次，我们设置title、date、content字段的store依次为true，true，false。 那么content字段没有存储，title和date字段均会存入“独立存储”
                     最后，我们检索时不能用正常搜索（有结果但拿不到title和date字段值），而要传递"stored_fields": ["title","date"]参数进行搜索，ES就会在“独立存储”里查找这两个字段值并返回。
                     注意：传递 "_source": ["title"]参数搜索则直接报错
  7、_source和store相关性能优化点：
            不管存储或搜索文档，都需要涉及到存储和IO及网络传输，所以我们上述第6点的最佳实践是在存储时进行处理。
            当我们存储文档时，如果只需要部分字段可以设置索引"_source":{"includes":["title","date"]}或"_source":{"excludes":["content"]},这样文档就只存储原始文档的title和date字段
            当我们搜索文档时，如果只需要部分字段也可以通过 "_source": {"includes": ["title"]}或"_source": {"excludes": ["content"]}进行筛选。减少读写量和网络传输。


*使用org.springframework.data.elasticsearch时，怎么配置索引的_source的enable=false？用什么注解？
 简单的索引配置用@Document(.....)，如果要用完全的索引配置跨域使用@Setting(settingPath = "your_index_settings.json")

*************** _source和store相关配置的理解  end ***************




******** ES的mapping配置相关 end ********

*ES各种概念和关系型数据库类比
数据库                 ES                        
database             index                         
table                   type（新版本已删除，当初是为了和关系型数据库对应）
row                     document
column                filed                    
schema                mapping

*倒排索引
 -相对于正排索引而言。 正排索引是指比如传统关系型数据库通过主键id索引快速找到对应的行或内容。
  id              content
  1001          我是张三
  1002          我是张三丰
 -倒排索引则是通过内容去找主键id
  keyword       id
  张三             1001,1002

*通过elasticsearch-head浏览器插件可以看ES集群状态
 在视图中通过黄色绿色灰色来标记节点分片的状态 ，比如副本变灰色说明不正常
 方块为分片，如果方块边框加粗则为主分片。
 带星号的是master主机节点

*ES集群添加新节点时，只要配置的 cluster.name是相同的，就会自动发现加入到集群中

？ES集群新增节点后数据分片副本可以自动平均分布
  场景：如果分片为3，副本为3（即每个分片一个副本)
           当只有一个节点服务器，则分片都会集中在这个节点
           当增加一个节点服务器，则副本会启用分布到其中一个节点，

*主分片数量在集群运行时是不能改的，副本数量可以改，副本数量多的话吞吐量就会提升
 
*ES集群中有master节点和slave节点，当master节点宕机，会进行master节点选举切换

*ES的分片拓扑和kafka是基本一样的，在客户端将数据提交到ES时，也有参数（kafka参数是ack）设置应答的模式，是直接返回或主分片完成返回或副本同步完成返回，这些是一样的。但ES一般默认副本同步完成返回
 另外consistency参数会对客户端读写ES产生不同的影响，即根据主分片、副本分片的数量进行限制读写（注意number_of_replicas 大于1的时候这些规则才会执行，因为1的情况下永远无法满足条件）
 当ES集群的主机增加或减少了，ES会进行分片的重新分配（包括副本），和kafka的消费者的reblance差不多一个概念。
 注意：主分片并不是互斥分配到不同主机，有可能有很多主分片会分配到同一台主机上。  

*注意了解ES集群的读写流程，核心流程都是在于连接任意一个ES集群主机节点（即协调节点）既可进行读写，至于协调节点如何进行路由、负载均衡都是在内部完成


*怎么确定分片：
 1、如果主机数量是固定的（设N），则主分片数量为N，而副本数则为N-1，这样能保持高可用和并发性
 2、如果主机数量足够，而有明确的吞吐量要求，则可以做单机吞吐量测试，然后再预留足够的机器保证高可用和并发性
      但是注意主分片在创建索引时就已经确定（它决定了存储数据的容量），副本数可调节，所以当主机数量够的情况下则可以增加副本数来增加查询的吞吐量

*ES中如果类似简历分了多张表，那么如何join查询。
  要点和注意事项详见csdn收藏《Elasticsearch之join关联查询》https://blog.csdn.net/lzxlfly/article/details/127925375
    一般ES存储数据的数据结构，我们都是按照前端搜索结果所需字段+搜索条件字段进行组织。 比如简历搜索只需要头像、名字、年龄等信息，则ES就存储这些信息
   注意：
       1、在Elasticsearch这样的分布式系统中执行类似SQL的join连接是代价是非常大的。然而，Elasticsearch却给我们提供了基于水平扩展的两种连接形式 。有人测试在6个分片的前提下，且子表数据量在千万量级的情况下，关联查询的耗时还是在秒内的，许多场景还是可以接受的。
       2、在es中为了保证良好的查询性能，最佳的实践是将数据模型设置为非规范化文档，通过字段冗余构造宽表，即存储在一个索引中。 如尺寸可能就会存英里和米两个字段，以空间换检索时间，提高查询性能

*spring-boot-starter-data-elasticsearch使用：
（springboot默认整合的客户端），一般都用高级客户端（要重新自己整合）
 参考收藏《elasticsearchRestTemplate客户端使用》
 *elasticsearchRestTemplate是低级别客户端
 在增删查索引库时有两种方式：
  1、通过IndexCoordinates类操作，如创建索引：
       boolean isCreate = restTemplate.indexOps(IndexCoordinates.of("base_info")).create();//直接使用字符串来指定索引名
  2、通过索引实体类的class操作
       boolean isCreate = restTemplate.indexOps(BaseInfo.class).create()//用BaseInfo类中注解信息来创建，如果报分片数量设置错误，则需要在BaseInfo注解中指定分片数量
  *几个操作的类
   elasticsearchTemplate.queryForPage   #是查询一个分页列表，用的就是一个对象实例
   QueryBuilders  查询条件构造器
   NativeSearchQuery 原生的查询条件类，QueryBuilders最终也是要通过NativeSearchQuery进行包装才能给ElasticsearchRestTemplate使用
   QueryBuilders                    #设置查询条件,是ES中的类
   SortBuilders                     #设置排序条件
   HighlightBuilder                 #设置高亮显示

*ES高级客户端
 因为该客户端保持与ES技术上同步更新，因此在性能操作等方面都比较强些
 引入依赖elasticsearch-rest-high-level-client
 配置：springbo并没有提供默认的配置（也没有注入客户端对象到spring IOC），要自己硬编码去初始化客户端对象（后期研究下如何去做优化）
 ？这部分要再写下测试demo

？主分片和副分片
   副分配应该就是主分片的副本，就是通常说的副本


？索引建立并添加了文档数据后能否进行分片调节（主分片和副本）
  主分片不行（副本可以），如果索引创建要调整分片数一般实践是先备份当前索引数据，然后创建新的索引并调节分片数，然后导入备份数据。
  具体实践：通过ES相关的restfulAPI进行数据备份、reindex等操作。最后可以通过查看新旧索引的文档数是否一致来判断迁移是否完成

ELK
  *ElasticSearch 搜索引擎
  *Logstash 做数据清洗、转换、收集（资源耗费大），使用时主要是对config文件下的logstash**.conf文件进行操作，在其中完成数据的收集、解析和输出的操作。
  *Kibana 提供DevTools、可视化、安全/监控、？企业搜索（此部分待学习）等功能
  *Filebeat 轻量级数据收集组件，解决了Logstash资源耗费大的问题，使用时也Logstash类似需要进行相应的输入输出配置

*注意：ES是比较消耗资源的，所以并不建议放在k8s里面。 当然如果有单独的k8s主机节点可以部署ES也是可以的。 

********* Kibana begin *******
 *学习资料：bilibli《【强推】非常炫酷的Kibana 可视化，半小时你也可以搞...》
 *官方文档 https://www.elastic.co/guide/cn/kibana/current/introduction.html
 *ELK架构的演变可看csdn《ELK介绍》
  ELK总体介绍详见csdn《Logstash：Logstash 入门教程 （一）》
 *相关概念：
   Index Patterns：索引模式，即相关应用（如图表）从哪些索引查询获取数据，例如：logs-* 是从匹配该模式的索引中查询获取数据。  在Visualize Library中的组件控件就可以设置它数据来源的索引模式（即从哪些索引查询数据）
                           注意：创建索引模式时可以与时间字段想关联，关联后则在【Discover】里选择改索引模式，会有一个时间筛选工具可供使用
   KQL：Kibana中提供的查询语法，只支持简单查询。并没有类似ES的lunces的分词搜索功能
 *功能模块：
   Discover 汉化后名称为“数据探索”，可以进行一些查询并将结果保存（类似mysql视图）  ？但是在哪里用呢
   Dashboard 可以创建管理Dashboard实例，即一个数据展示的仪表盘，里面可以创建或引入不同的数据图表控件，组成一个大的看板。
   Visualize Library 可以创建管理组件控件实例，包含了许多类型的数据图表组件控件的库
   注意：当你点击左侧Dashboard菜单时，一般默认进入创建/搜索页面，但有时候会直接进入到上次编辑的Dashboard实例页面中，此时可以多点击几次左侧的Dashboard菜单就可以进入创建/搜索页面

 使用Kibana的devTools会比elasticsearch-head更好用，有自动完成等功能
 主要功能划分：DevTools、可视化、安全/监控、？企业搜索（此部分待学习）
 整体使用逻辑：左侧主菜单包含了Kibana所有应用的形式。 在【Discover】菜单里可以导入数据（比如weblog），然后根据这些数据你可以创建Dashboard、Canvas、Map等不同的应用形式。
                      如要创建数据的Dashboard时，还有多种不同的Dashboard界面可供选择创建。
 云上示例环境：提供了一个线上Kibana，有试用期。详见 https://my-deployment-7ef547.kb.ap-east-1.aws.elastic-cloud.com:9243/    、 


*创建好的图表能保持成库，然后在应用（如dashboard）里引入

*整个应用（如一个dashboard）可以以不同形式分享（在顶部的【Share】菜单），里面有一个Short URL的选项可以分享成iframe

*使用中文地图：
  vim /etc/kibana/kibana.yml  编辑配置
  map.tilemap.url: 'http://webrd02.is.autonavi.com/appmaptile?lang=zh_cn&size=1&scale=1&style=7&x={x}&y={y}&z={z}' 添加配置项

？如果ES作为一个类似数据库一样的存储，Kibana似乎没有必要用ES，目前看到的图表也只是基于字段进行数据的图表显示，而没有用到ES的搜索功能
  是不是在图表里用到KQL可以实现一些ES的搜索引擎功能
                                                                            
Username
elastic
Password
bTgxi9uMF2tjZz0wrDsnGF6b

********* Kibana end *******

*阿里云部署计划：
 再买一两台一年机器组成VPC
 ES放在单独的机器上
 kafka、web应用放k8s里


*图片URL通常是一个字符串，为了确保数据的准确性和一致性，建议在索引映射中定义合适的数据类型，并确保URL的格式正确。同时，对于图片URL可能会有一些特殊字符，例如斜杠、冒号等，建议在存储之前进行适当的编码或转义，以避免在搜索和查询过程中出现问题。

*使用spring-boot-starter-data-elasticsearch进行文档保存时，根据@Document(indexName = "company")注解的实体进行创建mapping
 如果保存时字段没有值，在ES查询时候连属性名都不会显示出来


*在Elasticsearch中，字段设置type=Keyword和字段设置type=Text并且index=false有一些重要的区别，这涉及到如何对待和处理字段的数据。下面是两种设置的区别：
   type=Keyword：
           这种类型适合存储精确值，例如关键字、标签、ID等。
           字段的数据不会被分词，整个值会作为一个单独的词条存储。
           查询时，只能通过完全匹配来查找值，无法使用通配符、模糊搜索等功能。
           适合用于聚合、排序等操作。
   type=Text 并且 index=false：
           这种设置适合存储长文本、描述等内容，不需要被分词或索引。
           字段的数据不会被分词，整个值会作为一个单独的词条存储。
           由于设置了index=false，字段的数据不会被索引，因此无法通过该字段进行查询、排序或聚合操作。
           适合存储不需要进行全文搜索或其他类型查询的文本数据，用于展示、描述等用途。
           总的来说，type=Keyword适合存储精确值并支持聚合、排序，而type=Text并且index=false适合存储不需要被索引和分词的长文本数据。在设计索引时，根据实际需求选择合适的字段类型和设置，以达到更好的性能和功能。