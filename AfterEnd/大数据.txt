*课程学习bili《一套上手ClickHouse-OLAP分析引擎，囊括Prometheus与Grafana》  包含文档
*clickhouse 速度快、类sql语法、和mysql类似也有不同的表引擎（4大类20多种表引擎，可以根据不同场景自由选择），主要用户在线分析处理查询，对于更新删除不擅长、不需要Hadoop
                 插入更改数据时，老数据并未删除，只会在执行定期合并时再删除。 查询时通过时间戳获取最新版本的数据。
                 和Kafka一样顺序写入磁盘，数据分区、线程级并行（吃cpu，导致高qps处理不强）、所以快。适合处理完的数据，如宽表数据。
                 插入、更新、join效率不高，尽量避免。 例如：A表join B表，则会先将B表数据加载到内存，然后一条条和A表对比。  单机性能都很差了，更何况多机
                 集群依赖zookeeper
                 *使用数据类型Nullble，会对性能产生负面影响，即使从其它数据库导过来的null数据，也尽量不存Nullble，存一些标志
                 *clickhouse MergeTree建主键时并不会像mysql那样加上唯一索引。 orderby字段是必选的
                 *clickhouse建表时可以指定分区规则，比如按时间字段分区，和kafka类似，单分区有序。  如果不定义分区则默认all分区。   个人理解不会造成数据倾斜的原因是因为列式存储结构。 
                 *clickhouse的写入分区合并过程：写入数据会先写入临时分区，然后等定期或手动合并才会将临时分区数据合并到实际分区中。临时分区后面会再删除。
 	   *稀疏索引：常规索引是对每条数据都做索引，而稀疏索引则是隔一段去一条做索引。类似一个二分查找。
                 *主键必须是orderby字段的前缀字段，比如orderby字段是id,name,age。则主键必须是id或者id+name或id+name+age，不能是name或age之类的，和mysql的前缀索引有点像。
                 *clickhouse的一级索引是稀疏索引，相当于是一种分组然后索引，而二级索引则是在一级索引的分组之上又做了一次分组索引，相当于二层数组。这和mysql的二级索引原理概念不同
                 *TTL，设置数据过期时间（可以是字段或表级别），过期就会变成默认值。 但是注意即使设置过期时间，也要等到分区合并后才能清除数据
                 *replacingMergeTree引擎，用于需要数据去重场景。是单分区内去重。因为只有在分区合并时才会去重，所以想要达到数据保证唯一（数据一致性），要采用“自己去重”、“final”、“手动合并分区”
                 *summingMergeTree引擎，用于需要数据聚合场景。  它会根据orderby字段对单分区内进行预聚合
                 集成：通过配置映射，可以让clickhouse连接到mysql、kafka等存储库上。
*clickhouse拓扑：
                副本：各个副本都是互为副本，没有主从之分。数据相互同步。通过zookeeper协调
                分片：

*Hbase也是列式存储数据库，列式存储适合查询，大数据处理。
          插入更改数据时，老数据并未删除，只会在执行定期合并时再删除。 查询时通过时间戳获取最新版本的数据。clickhouse也是类似原理
          