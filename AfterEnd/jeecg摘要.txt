******计划8月19~11月19用3个月完成eecg总体框架学习：前端，后端，数据结构******

************************前端 begin******************************
？注意vue extend和minix的区别，前者有点像继承，数据和方法是所有组件共享的。 后者有点像字节码混入，数据和方法不共享但却是可以动态注入到特定组件中。

*在前端的页面中visible数据来控制一些弹窗的显隐

*v-model和v-decorator的区别，前者是双向的，后者是input改变会传递到model，但是model改变不会传递到input，可以通过this.form.setFieldsValue()刷新到input里

*前端的路由不是固定的而是在permission.js里配置 路由前置守卫拦截处理

？vue的路由学习

*jeecg常用的前端组件，在系统页面菜单：常见案例-自定义组件。代码封装在src/components/jeecg

*前端路由逻辑：
 1.在permission.js做前置守卫拦截添加路由列表
 2.通过后端获取的菜单列表menuData生成路由列表constRoutes
 3.menuData里的菜单项的component字段代表页面组件，children代表子页面组件。

*前端的登录状态逻辑:
 *在整个App初始化的在main.js里如果有开启VUE_APP_SSO=true 则会通过是在src/cas/sso.js 做cas验证，整个cas单点登录逻辑在官方文档有流程图
 *如果没有开启cas验证功能则正常初始化App，并且通过在permission.js的路由前置守卫进行普通登录检测
 ？？具体的cas项目的服务部署实施及使用需要再学习。 可以通过docker镜像部署   博客园《CAS单点登录系统简介》可做简单了解。
************************前端 end******************************


************************后端 begin******************************

？启动时一直报“Error from chokidar...”错误，对后续的调试热更新是否有影响  
 网上用的解决办法是在终端输入一下命令即可
 echo fs.inotify.max_user_watches=524288 | sudo tee -a /etc/sysctl.conf && sudo sysctl 
 ！！应该是在虚拟机内部有限制，在物理机下运行就不会报那个错误。

？代码生成时候的包名为什么一直会多一个“demo”，比如增加一个test模块,包名项为cc，生成的org.jeecg.modules.demo.cc.controller.TestController
   代码生成功能相关模板又是在哪里配置
  ！在src/main/resources/jeecg/jeecg_config.properties配置
？生成的代码前端页面更改时不能自动刷新
？以上问题都需要了解代码生成的总体原理，框架结构

*除了在线代码生成还可以运行代码里的GUI进行代码生成：
 1.配置src/main/resources/jeecg/jeecg_config.properties里的project_path（生成代码存放目录）、bussi_package（基础的包名）
 2.运行src/main/java/org/jeecg/JeecgOneGUI.java 其中包名项是在1步骤配置的bussi_package上叠加
 *注意：在线代码生成和GUI的配置都是1步

*代码生成功能使用时，在相关配置完成后要重启前后端项目才能生效
 代码生成功能在配置菜单时注意：
 *一级菜单的组件都是“layouts/RouteView”  
 *【默认跳转地址】是指上一级菜单点击默认跳转的地址，因为上一级菜单底下有多个菜单。
 *【隐藏路由】大概就是该页面不会在左侧菜单列表展示出对应的菜单项。？？待测
 *【聚合路由】大概是说比如A菜单下面有A1，A2子菜单，但是在左侧总菜单只想让A菜单展示，点击A菜单后右侧展示A菜单下的A1，A2的一个聚合页面。这个聚合页面还是会有A1、A2菜单栏

*数据权限
 实现：代码上处理，在线编码。 
 基本使用逻辑：前端或后端在对应的地方做权限埋点，然后在系统中添加权限控制菜单项和给对应角色分配菜单。
 *前端权限控制
  hasPermission.js定义的has指令用于控制页面元素的显隐，和shiro的页面权限标签类似（如admin:addUser)。 详见官方文档 http://doc.jeecg.com/2044038
  比如：页面按钮元素添加这个“admin:addUser”后，在对应的页面的菜单里配置按钮权限时加上“admin:addUser“，最后还要在角色管理里做下授权。
  以上是元素的显隐控制，如果是要是否可用控制则用disableAuth来控制disabed属性，但是菜单按钮权限配置的【授权策略】就要是”可编辑(未授权时禁用)“
 *具体实践（详见官方开发文档）：
  1.通过角色限制访问页面
  2.通过角色限制前端页面dom元素的显隐，如add按钮，并在后端controller验证限制
  3.通过角色限制前端页面数据表格列显隐，后端数据没控制
  4.通过角色限制用户访问数据的范围，基本逻辑是：特地用户是特定角色，特定角色有特定菜单项，特定菜单项有特定的数据范围（即【数据权限规则】）
  5.通过我的部门分配权限？？一个用户可以在其负责的部门（我的部门）里为这个部门添加”部门角色“，并且给这个负责部门下的用户分配”部门角色“，但是这个部门角色的用处是什么。
 *特别注意：
   列权限控制时，在js中的权限标识是除去列名后的部分。 如权限标记是"cny:interesting",则在js里配置的是"cny:"
   注意实际页面访问控制和按钮/数据列等零部件的显隐控制也都是需要添加菜单节点，只是后者添加的是“按钮/权限”类型的菜单权限。
  ”我的部门“实际上就是当前用户在创建时的”负责的部门“选框

*增值规则：其实就是自动生成编码的一种实现。 添加相关接口实现类并在【系统编码规则】添加记录myCodeRule，然后在线代码生成时配置对应表单页面属性的【空间默认值】赋值，如${myCodeRule}


*Copilot是AI代码生成工具，由Github研发出来的，自动代码生成代码。 其实个人理解就是基于github上开源代码进行AI学习，并进行自动化提示
 imgcook是设计图切图代码工具，可以作为插件附加在PS、Sketch上，根据设计图自动生成代码




*权限注解：
  数据权限通过自定义aop拦截，@PermissionData注解是用于有添加数据规则权限的，而不是普通的菜单权限
  菜单权限通过shiro的各种注解拦截，@RequiresPermissions




************************后端 end******************************