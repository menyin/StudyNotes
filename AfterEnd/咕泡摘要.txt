*咕泡学院入学时间：2018.11.1

*大黄蜂账号 845257580陈向阳   密码127185

*小炮播放器下载地址：https://pan.baidu.com/s/1qXnxYriA7LbvvmurI_51zw 
提取码：tkah
使用教程：https://gper.gupaoedu.com/gper-doc/tencentKT.html

*架构课程4.0
 源码分析专题（Tom/James）
 微服务架构专题（小马哥）
 性能优化专题（James/小马哥）
 分布式架构专题（Mic/Jack）
 并发编程专题（Mic）
 电商项目实战（Mic）
 团队协作专题（James）

*咕泡资源（这些资源在换工作及新工作解决问题中都是很好的资源）
 qq群：有众多的学员分享交流
 BBS、ASK、Gper生态圈：学员老师都会回答你的问题、分享面试经验。可以积分，积累经验
 老师：主要解决个性问题，如职业生涯，工作碰壁，面试问题，沟通技巧...
 微信公众号：课程提醒、学籍信息、作业提交情况、毕业跟踪等
 GitLab：包含课程源码、问题集锦
 云盘：放置录播视频、预习资料、课后作业
 定期给学员做软实力提升、HR技巧分享、英语提升？？这部分内容在哪
 咕泡分布式架构：看架构图，已经是一个成熟的互联网框架。
 内推机会：对于全国名企有一些招聘需求可以get到
 
*gitlab使用学习
 *链接：http://git.gupaoedu.com 用户名密码 menyin gdlr...  邮箱8425...@qq.com
 *咕泡通过gitlab的项目（your projects）来划分不同的版块，主要模块划：问题区vip/qa、作业区vip/static、公告区vip/nice等
  每个区都是以一个项目的形式存在，其中包括以下版块：
    --Overview 概况
      --Details 详情
      --Activity 动态
      --CycleAnalytics 统计
    --Repository 仓库
      --Files 文件
      --Commits 提交记录
      --Branches 分支
      --Tags 版本或里程碑
      --Contributors 贡献者
      --Graph 图像
      --Compare 对比
    --Issues 问题点
      --List 列表
      --Board 版块？
      --Labels 标签？
      --Milestones 里程碑？
    --MergeRequests 合并需求？
    --Wiki 维基？主要是一些附加的知识点文档
    --Snippets 片段？应该是用于部分代码分享，即“Snippet support”功能
    --Members 参与的成员
 *github、gitlab的.md文档，issue都使用Markdown语法，可以下载typora编辑器进行编辑（intellij亦可）。学习https://www.jianshu.com/p/191d1e21f7ed
 *在qa区中发issue时，右边有个todo面板，可以设置label来标志紧急程度


*计算咕泡的总课时安排学习计划（和淘淘对比下）
 课程大致分为：常用框架源码解析、分布式、微服务架构、jvm及性能优化、并发编程
 ？先博后专、？思维方式、？先总结规整知识要点整合taotao+jeesite、？将近期学习实践的要点梳理一遍、问题找咕泡讨论一遍


*咕泡课程学习注意（整套课程一定要多实践）：
 分布式课程（2-3个月）最好是看直播，有一些问题可以直接提出。结合架构图进行学习
 微服务课程（1个月）会涉及spring源码，因此在此之前要学完spring源码部分
 多线程、并发、性能优化涉及jvm，因此在此之前要学完jvm
 实战项目是穿插在各个部分的课程中

*问答流程：vip群聊、gitlab/qa、私聊老师。以后可以简历指导和面试指导

*翻译小组，可以学习英文技术文档 http://git.gupaoedu.com/vip/nice/wikis/%E7%BF%BB%E8%AF%91%E5%B0%8F%E7%BB%84

*咕泡生态圈 https://gper.gupaoedu.com/

*Tom老师和我的技术路线基本一致，喜欢思考，个性也比较像，喜欢艺术，哈哈

*Mic等老师用了一款在线绘图工具，很方便，可绘制流程图、思维导图、原型图、UML、网络拓扑图、组织结构图等。详见 https://www.processon.com/

*前人经验：https://gper.gupaoedu.com/articleContent?id=26    https://102.alibaba.com/downloadFile.do?file=1530517140411/Codelife.pdf

？《5月下旬学习指导.mp4》22分提到明天下午有英文课程，是指什么课程？

Tom老师，你好，
   想找您咨询下一些问题，我的情况大致如下：
   *java开发七八年，主要还是传统项目，今年更多的是做前端的工作。
   *对互联网分布式技术有一定了解，能自己用zookeeper、dubbo、nginx等搭建出基础分布式的架构环境。
   *知识有一定体系，技术涉猎有java、C#、前端，总体知道自己该如何学习进步，但缺乏互联网经验。

？找各个老师交流下：
  *英文水平不是很好，看英文技术文档都是用翻译软件，提升这方面能力有什么建议，技术文档有没有一些格式和套路。
   因为学习一些技术的时候，通常都是找找视频教程和中文文档，然后有时候要折腾很久。
   james答：花一个月硬啃技术官网：http://spring.io/  https://spring.io/projects/spring-framework
  *硬件和网络方面的知识也比较欠缺，有什么建议
  *11月半路出家，从哪部分开始切入好，还是从头开始看录播。我工作相对比较轻松，时间也充足。（老师似乎建议直接跟直播，后面再挑着看录播）
  *很多技术问题会知道如何解决，也能很快的判断出大致的原因，但要找找资料，这个算基础薄弱吗？需要改进吗？ 
  *如何去模拟高流量，高并发，让自己能更多学习到实际场景中的一些问题。（老师建议不断思考场景，不断想象，不断折腾，参与到互联网公司环境，建议跳槽）
  *我在厦门，这里的名企不多。而我就职的公司又属于半传统半互联网的公司，互联网技术经验不够，我想进这些名企，有什么建议。
  *在一个具体的城市，如何定位自己能力和这个城市这个职业的薪资水平，有哪些点需要注意。
  *电商实战项目，云服务器要不要提前买下，快到双十一了
  *全国分舵有线下交流活动，厦门这边好像是没有，能不能组织下。

 *和Tom聊天如下：
  我：
  1、英文水平不是很好，看英文技术文档都是用翻译软件，提升这方面能力有什么建议，技术文档有没有一些格式和套路。
   因为学习一些技术的时候，通常都是找找视频教程和中文文档，然后有时候要折腾很久。
  2、硬件和网络方面的知识也比较欠缺，有什么建议
  3、11月才加入咕泡，从哪部分开始切入好，还是从头开始看录播。我工作相对比较轻松，时间也充足。
  （入学指导视频中，老师似乎建议直接跟直播，后面再挑着看录播）
  4、很多技术问题会知道如何解决，也能很快的判断出大致的原因，但要找找资料，这个算基础薄弱吗？需要改进吗？ 
  5、如何去模拟高流量，高并发，让自己能更多学习到实际场景中的一些问题。
  （入学指导视频中，老师建议不断思考场景，不断想象，不断折腾，参与到互联网公司环境，建议跳槽）
  6、我在厦门，这里的名企不多。而我就职的公司又属于半传统半互联网的公司，互联网技术经验不够，我想进这些名企，有什么建议。
  7、在一个具体的城市，如何定位自己能力和这个城市这个职业的薪资水平，因为我从事互联网方面的朋友不多，所以比较没人可交流。
  Tom：
  1、英文文档其实很简单，坚持记单词，时间久了就有感觉了。技术类的文档，对口语和书写没有任何要求，只需要能看懂就行。
  2、硬件知识可以去看看运维相关的教程
  3、先看设计模式、源码专题、和分布式专题，如果时间充裕可以先跟直播
  4、提升技术解决效率，需要提升思维能力
  5、利用阿里云或者虚拟机，自己搭建一个比较固定的分布式环境，重在实操
  6、进名企要去一线城市，可以找找所在城市的分公司
  7、了解行业水平可以去各大招聘网站，看招聘需求。现在来了咕泡，要好好利用好这个圈子。

----------------------------2019课程 begin-------------------
*james
2017 1k+学员
2018 3k+学员
*mic说
 3期可能增加 训练营方式，创建一个21天的临时群做任务。
 学习方式：知识链，知识体系。推导式
 提到的东西：ConcurrentHashMap、阻塞队列、
 跳槽频繁差不多一年一次，清楚自己的方向。
 阿里P8 可能不只是技术可能还有30%的产品思维、管理能力等
 面试过程中，如果遇到一个需求问题，首先需要了解好动机、需求、目标（性能、并发等），场景等，最后在做方案细则。
*tom说
 增加创业扶植项目源码
----------------------------2019课程 end-------------------

*版本冲突后

*测试直接test分支开发的问题、测试test分支再分出dv1分支开发的问题。

*测试版本回退与当前版本
 三期课程大纲，注意和一二期对比
 课程体系：内功心法.....


？Jenkins如何做到实时提交单独的文件

--------------------设计模式 begin----------------------------
*单例模式中的饿汉模式能保证线程安全，即在多线程并发访问该实例都是同一个对象
 而懒汉模式则不能，因为它是延迟创建实例机制，所以多线程同一时刻有可能创建多个实例。

*懒汉模式用synchronized解决线程安全问题时，在创建实例的时候性能很低。
 懒汉模式用内部类解决线程安全和性能低问题，但会有单例反射攻击问题可以参照LazyThree类处理

*序列化实现单例，要求被序列化的类添加readResolve方法，以保证反序列化时是同一个对象。相对比较复杂

*最科学最推荐的单例实现方案是内部类实现法。此法需要放反射构造函数注入，需要用final固定死getInstance方法
 ？在此法中，如何在防反射构造函数攻击时使用到标志变量，此时又该如何防止此标志变量被反射攻击呢。
   tom直接将这个标志变量设置成非静态的即可，即必须有实例才能访问。

*双重检查锁定（这种方式是比较常用的一种方式） if (instance == null) {synchronized(）{if (instance == null) {xxxx}}} 
 详见CSDN收藏《Java单例模式中双重检查锁的问题》 https://blog.csdn.net/chenchaofuck1/article/details/51702129

*在动态代理实践中，在intercept拦截方法内部断点，监控到代理生成对象时会调用它的toString方法，
 因此这个拦截方法会再被执行一遍，而且不会走到你打的断点处，感觉莫名其妙，但其实很合理。

*动态代理后的代理对象无论怎么转换还是直接用Object接收，其getClass()都是com.sum.proxy.$Proxy0类型，非常重要
 这也是Proxy.isProxyClass()方法的判断依据

*动态代理，其实是生成一个目标类或接口的代理对象，这个代理对象所有方法（即目标对象对应的方法）里都是调用Invocation实例的invoke方法
 并且把当前代理对象和目标对象的方法及参数传递过去。在代理对象类的invoke方法里，一般就是添加一些附加逻辑代码
 然后在将目标对象的原始方法执行一遍（即将原始方法invoke以下）
 其实这个代理对象的类是动态生成类字节码（字节码重组）然后加载到内存，这个动态类一般都是$ProxyX,X是数字，$ProxyX是继承java.lang.reflect.Proxy

*明白动态代理原理后，应该知道如果目标对象有私有成员变量，如name，但代理对象是没有name这一变量，但是如果目标对象遵循java get set规范
 则代理对象会有getName和setName方法。所以在spring环境下的bean要反射得到私有成员变量不能通过Field而应通过Method，这就是Tom老师的方式

*JDK中有个不成文的规范：只要是带$开头的类就是自动生成的，如$Proxy0

*委派模式其实就像一个不干事的中间调度器，Spring中带有Dispatcher、或Handler的一般是用委派模式

*在java中带Decorator或Wrapper的类都是采用装饰器模式，或者说是包装器模式

*注意适配器模式和装饰者模式的区别：
 适配器模式注重通过扩展旧的类型来使新的数据能适应就类型方法的数据要求
 装饰者模式注重于在一个新的类中将旧的类实例传入，对就类实例的方法进行加工扩展，比如游戏放大招方法增加发光效果。
 java中适配器类型处理的旧类型经常会用@Deprected标记过时类或过时方法

*观察者模式≈发布订阅模式≈事件模式  
 Spring中的ApplicationListener就是观察者模式

*Spring常用的几种编程思想：AOP、OOP、BOP、IOC、DI  具体看咕泡的截图摘要
 Spring加载步骤：定位，载入，注册，再确定要不要初始化Spring

*各种设计模式的区别看《咕泡学院_Tom_JavaVIP课程_Spring源码分析(第二版)_第一章.pdf》

*多线程测试demo中常用countDownLatch，类似loadrunner里的集合点。 可以阻塞主线程，然后都其它线程达到计数器的数后才继续执行主线程。
 

？复习下 java封装、继承、多态的几种实现方式，如抽象...


？咕泡还介绍了一种在java类里对进行注解以获取sessionfactory的使用mybatis形式，如MybatisConfiguration.java

？注册式实现单例时，使用ConcurrentHashMap还是不能保证单例安全，怎么解决
 
？实践：
  懒汉模式下保证线程安全，用synchronized，性能问题
  synchronized，这个关键字需要学习
  内部类的初始化过程、java类加载过程原理
  反射入侵是个什么问题
  枚举类
  Vector 

？通过反编译工具ProxyGenerator来获取动态代理生成的代理类的字节码，然后输出到文件中
？策略模式中具体的策略能不能放入Spring的ioc容器，在代码中用ioc容器获取多个具体策略实例
？实践用intellij查看接口的实现类图



--------------------设计模式 end------------------------------

--------------------Mybatis begin------------------------------

*lombok  可以通过一些注解使得书写类代码时省略掉 get、set、toString等方法，但实际是有生成的。

*mybatis使用的代码生成器generator生成的会生成一个XxxExample，它会将开发者书写的条件生成sql然后执行。
 对于开发者是好事，但会有一些问题，不推荐使用。

*sqlsession是线程级别或者说是request/response级别的，也就是说这个sqlsession是存活在一次web请求中的。
 sessionfactory是application级别的，是整个web应用启动后创建并存活的。
 ？一个service多个dao是在一个线程里吗？ 

*mybatis的sql语句可以书写到mapper类的注解或者mapper.xml，这两种方式可以兼容吗  
  ！是可以的，但是这种方式里的id不能一样。如mapper.xml有<sql id="getUserById"/> 那用注解的mapper类就不能再有getUserById方法
  一般我们也不会将sql语句写到mapper类的注解里，如果sql复杂则mapper类很混乱，不好维护。

*mybatis插件原理学习：
 *mybatis原理请看CSDN收藏《Mybatis之工作原理》、博客园收藏《MyBatis插件原理----从<plugins>解析开始》
 *使用时可看官网文档，并且像mybatis-config.xml可查看其DTD文件
 *结论：1.mybatis插件中@Intercepts是描述定位了要拦截的类和方法
        2.intercept(Invocation invocation)是提供了一个拦截点供实现，其中invocation包含了当前目标拦截的方法的实例、参数等信息
          invocation.proceed();即执行了当前目标拦截方法（原有的）。在此我们可以做要拦截的处理。
        3.plugin(Object target)中target即要包装的目标实例。在此方法中一般我们用return Plugin.wrap(target,this);直接返回当前
          拦截器作为代理对象。其实也可以自己通过对target的做代理包装，然后返回，此时intercept(Invocation invocation)可直接
          用return invocation.proceed();
 *整个过程：mybatis用ExamplePlugin1.plugn()包装后的对象作为原始对象的代理对象，然后执行相关方法时其实是用ExamplePlugin1.intercept()执行

*嵌套查询和嵌套结果
 嵌套查询，指在resultMap里嵌套通过当前查询结果的外键字段再去映射另一个mapper里的sql查询，已达到关联查询的目的
           会产生1+N次查询问题，产生性能问题。 如果要避免无谓的查询，可以用懒加载。
 嵌套结果，指在一个mapper里就把主实体和关联实体的字段通过join方式一次性查询出来，并映射到resultMap上，已达到关联查询的目的

*在spring web环境下，一个request就是一个线程，并且controller、servic、dao都是单例，但此时sqlsession是通过ThreadLocal实例和当前线程绑定的
 注意一个service里可能用到多个dao，但他们应该都是同一个sqlsession。但是每个dao应该都知识有一次连接（即connection）

*mybatis的二级缓存是以实体的命名空间为单元的，如Student 完全限定名为com.cny.Student，则以此为单元。当这个单元的任何内容有增删改才会清除这个单元的缓存
 如：其中有一个getStudenById，那它的缓存key应该大概就是com.cny.Student.getStudenById。
 注意，如果getStudenById结果集关联包含Teacher，则Teacher的也是缓存在com.cny.Student.getStudenById这个key下。 此时如果去增删改com.cny.Teacheer单元的缓存
       则com.cny.Student.getStudenById里的Teacher是不会被更新的，即会有脏数据。

*method.getDeclaringClass()调用方法的getDeclaringClass()是获取方法的声明类型

*jdk1.8后接口中可以用default修饰方法，相当于C#中的虚方法有默认的实现
 这样要扩展接口方法后，之前已实现该接口的类不会受到影响，否则编译会报错。

*mybatis架构几个重要的类或接口
 Sqlsession 
 Configuration 
 Excutor
 StatementHandler
 ParameterHandler
 ResultSetHandler
 TypeHandler
 BoundSql
 MapperStatement
 MapperProxy 

**一般一个抽象类实现一个接口，通常是用到了模板模式。即抽象类对接口规约的方法的实现里包含了一些流程（如a->b->c）。
 此时a、b、c又被抽象类定义为抽象方法供子类实现。相当于子类参与了整个流程的一部分，即模板模式。
 注意：mybatis大量使用这种设计模式。如果这个接口有多个抽象子类，则相当于有多个分类。
 注意：Executor、CachingExecutor、BaseExecutor就属于这种情况
 
*BaseExecutor#query第1行代码什么意思，课程上没听明白。
*ErrorContext就是利用ThreadLocal变量记录当前线程的相关信息，包括执行到哪、以及报错信息等。等到程序出错时则可以输出这些信息。
*ErrorContext的工作过程， 和Exception一直往上抛后内存溢出问题有什么关系。
  《VIP-20180331-源码分析之3.3源码解读.vep》48分处有讲解到
 寻找答案的过程：
  1.明白它的作用后，我构造一个mybatis使用过程中的错误，即在执行查询方法前，将sqlsession关闭。
  2.此时在ErrorContext的toString方法上打断点，当进入到该断点就可以查看它的调用栈了。

* sqlsession、excutor、configuration、StatementHandler、ResultsetHandler、MapperProxy的关系。
  *查看excutor的类层次关系，发现它归为2大类CachingExecutor和BaseExecutor。
   而CachingExecutor是用于装饰BaseExecutor的子类，使之拥有缓存功能。
  *sqlsession持有excutor和configuration实例，然后将相关工作交给他们两去做
   SqlSessionFactory在创建sqlsession之初会先创建configuration，再由configuration生产excutor
   然后将configuration和excutor交给sqlsession，sqlsession尽情的调用这两个去实现功能。
  *MapperProxy.invoke()时 调用sqlsession调用cexutor调用StatementHandler调用ResultsetHandler


？UML图的学习


？spring环境下mybatis的mapper类即dao类是单例，是如何实现的
  这里注意数据库的connection是肯定是多例
  如果说并发很高，一个request就对应一个数据库连接吗 
  ！mysql的最大并发连接数跟硬件配置有关也跟所做操作和服务配置有关：


？BaseExecutor#queryFromDatabase 322行这行代码的意义
占位符，当延迟加载时，会先判断一级缓存中是否存在结果，如果没有结果或者为占位符，则将此延迟对象加入延迟队列，
否则直接从一级缓存中获取结果

？UML图的学习

？梳理调试StatementHandler、ResultSetHandler等过程。

--------------------Mybatis end------------------------------

--------------------Spring begin------------------------------
*spring有一个大的设计思想特点，它把很多的功能实现都集中在一些具体的实现类，如ClassPathXMLApplication，然后通过
 许多不同的多层次的接口来划分这些功能，并通过一些多层次的抽象类来规定不同的流程模板。所以在spring中一个实现类有
 可能扮演着多种“角色”

*spring IOC容器大概的过程：定位->加载->注册  
 大致流程可以看自己的demo代码
 具体过程详见博客园收藏 https://www.cnblogs.com/ITtangtang/p/3978349.html#a1

*spring IOC容器相关的一些类
 带resource的是关于资源的描述类，用于定位
 带BeanDefinition是bean加载后的描述类
 带Reader的是加载相关的类
 带Factory、Context是注册bean信息的相关类

*beanFactory和factoryBean的关系
 factoryBean是一个接口，自定义一个实现它的类，然后将类配置到spring xml里就可以得到一个代理目标对象的bean并放入ioc容器。 
            例如在spring mabatis整合过程中SqlSessionFactoryBean就是对原生的mybati的ssqlsession的代理
 beanFactory是生成bean的，包括有些beanFactory也是由其它beanFactory生产出来的bean（它会带有&符号），即factoryBean

*在spring生产原生bean时，要用beanDefinition和beanWrapper对原生的bean对象进行对象创建和属性赋值，beanWrapper是一个接口，
 她规定了原生bean的属性访问器和编辑器等操作（BeanWrapperImpl是其实现类），有了它就可以对原生bean进行属性进行填充。
 注意beanWrapper也只是在spring内部使用，开发者并不会使用它进行业务开发。
 

*spring中lazy-init默认是false，在源码中，它有一个finish...方法进行自调用，其实就是调用getBean方法。

*springmvc中的DispatcherServlet.onRefresh()调用了initStrategies(),这里初始化了springmvc的“9大组件”，这些组件所用的策略
 其实是在spring的xml配置的，如视图解析器组件一般都是配置org.springframework.web.servlet.view.InternalResourceViewResolver

*springmvc的DispatcherServlet.init()经过层层调用初始化了9大组件后（放在成员变量），
 然后在用户请求调用DispatcherServlet.doGet() 时依次调9大组件，最后返回结果给用户

*spring事务中，Datasource是对Connection的包装，Connection的实现其实是通过Socket进行数据库连接
 DataSource中其实是对事务的开启，隔离级别，回滚，提交等操作做了封装和规整。

**spring可以配置事务在一些异常出现的情况下进行回滚（rollback-for属性），但要求在业务service里不能把可能异常的代码try-catch掉。

**spring的service层的方法如果有相互的调用要特别注意会有事务传播问题，这个需要开发者注意。

*实际上数据库的事务的底层原理也是通过操作日志来做数据回滚，如mysql的里有一个binlog就是干这个事情的。

*spring的aop切面配置时，使用xml和annotation方式的区别：annotation可以额外配置匹配目标方法是否包含某个参数名的参数

*？在spring环境中通常一个Service里包括多个Dao处理，他们公用一个Connection，在一个事务中，此时Connection底层应该有多个socket对应
  不同的Dao操作，而每个socket可理解为一个Sql语句。这些语句在操作是在数据库内存中有个临时区域，等事务提交后才能更新到原始表。
  此时如果有其它事务访问原始表，则可能出现所谓的脏读，不可重复读，幻读的情况。而隔离级别就是规定了在这个事务期间原始表可访问情况。


？Tom的泛型操作类要研究学习下 javax.core.common.utils.GenericsUtils

？练习：Junit4和spring的集成、并复习Junit的使用

？元旦节后将spring最后这几节课的笔记再复习一遍
  元旦节后找spring相关的面试题做做，到咕泡论坛上找找
-------------------------------------------------------------
？下午复习下Spring事务的相关配置及事务传播和隔离级别

？<tx:annotation-driven>、<mvc:annotation-driven>和<context:component-scan>功能上的关系

*学完源码后要找相关的面试题做一做

？在描述DefaultListableBeanFactory到BeanFactory的关系时，他们是继承关系，tom说这是委派模式，但个人感觉不是。 
  委派不应该是调用的关系，而不是继承或实现的关系。 

？spring的aop在实际中有什么应用
？原生bean经过beanWrapper包装有什么用处，是为了aop吗

？RandomAccessFile类的使用学习，网上找了都比较简单

？spring在getBean()得到的是包装后的代理对象，没有原始对象的注解信息，如果开发者要用到原始对象的注解信息怎么办

？多数据源共存的情况下，如何去处理多个数据库的事务，应该属于分布式事务。

--------------------Spring end------------------------------

--------------------分布式20190110 begin------------------------------
*咕泡分布式项目实例 http://git.gupaoedu.com/java-vip/vip-project-space

**dubbo的官方文档多研究多看，可以窥探到分布式环境下的许多知识点以及编码风格和习惯。

*领域驱动，个人理解：即按照不同行业业务，将业务里的功能拆分细化，即拆分为不同的领域。如dubbo源码里就分了不同的模块，有admin有rpc等，这应该是就是不同的领域。
 应该说是按照行业领域去建立模型，比如将烟草采购这样一个业务抽象成模型或者说是类，在这个类模拟了这个业务，具体的一些过程操作等都做这样的模拟，做面向对象。
 mic在课程中提到领域案例代码是在service层和dao层添加领域层，这个领域层个人理解就是按照业务划分了细颗粒度的模块并在一些聚合模块进行组装，从而供service层用。

*分布式环境下，数据的一致性怎么保证。 其实一般会用一种中间状态做处理。 比如下订单业务，一般是要支付完后才算下订单完成。但是由于支付是一个相对耗时的操作，这
 时就会先返回给用户“下订单成功”，然后在订单中的支付状态是支付中，而不是支付完成。这种中间状态是一种软状态。 等到支付完成后会通知更新订单去更新支付状态。

*A/B测试（灰度测试），大概就是内部的测试，软件公司会征集一定范围的用户去试用新的产品功能，以达到测试新功能的目的。

*socket时讲到NIO和BIO时，其实同步和异步一般是对于客户端来说，而阻塞和非阻塞一般是对于服务端来说。
 *对于BIO进行通信时
  1.客户端和服务端分别需要有发送缓冲区和接收缓冲区，服务端不将接收缓冲区内容读取到内存，接收和发送缓冲区都不会清空，客户端就不能继续发送剩余字节。
  2.在此时如果别的客户端要连接服务端也进行通信就不行，因为已经被上述客户端占用，直到这个客户端处理完，对于所有客户端来说就是阻塞的
 *对于NIO进行通信时（应该和NodeJs的事件轮询机制是一样的）
  1.客户端和服务端在通信前，会建立一个个通道，每个通道对应了一个客户端和一个服务端。通道里保存了客户端和服务端的一些操作。
  2.在通信时会有一个线程去轮询这些通道，发现那个客户端的发送缓冲区清空了，就去执行对应通道里的动作，网发送缓冲区去写。
  3.由于轮询线程的速度是非常快的，看起来就像是所有客户端都能同时和服务端进行通信，达到异步的效果。 
 *BIO就像以前没电话搬运工找工作，每天都各个码头需不需要搬运工。BIO就像有了电话后，然后你就给码头留个电话说有需要再打电话找我。

*常见的序列化工具 Jackson、FastJson、GSon、Hesian（dubbo用的是它的扩展Hesian2）、
 dubbo除了Hesian2以外还提供了很多序列化的实现方案（实现类）
 Protobuf是mic推荐，独立语言、可跨平台交互等诸多优势，但它要实现比较麻烦，需要学习成本。
 序列化方案的选型考虑的点：1.开销，大小和性能 2.计算耗时  3.是否跨平台 4.学习成本

*Protobuf 官方支持C++、JAVA、Python等三种编程语言，但可以找到大量的几乎涵盖所有语言的第三方拓展包。
 javascript前端可以使用protobuf 详见https://blog.csdn.net/arvin_kai/article/details/77532595
 行业已有的实践：Protobuf+Websocket做一些行业应用、Protobuf+Redis做缓存

？测试Controller调用分布式的service实例时想service传递对象参数是通过序列化和反序列化传递的
 ！通过debug 在Controller的service方法调用之前 和之时查看参数对象的内存地址

*？通过课程了解RPC框架RMI的原理
   个人初步理解RPC远程通信实现Controller里获取Service实例并调用的过程（以HiController、HiServiceImpl、HiService为例）：
   HiServiceImpl实例通过固定的RPC框架的规范进行注册，RPC框架会生成HiServiceImpl的代理（HiServiceImpl_stub），并在宿主进程里保留HiServiceImpl实例
   通过序列化和反序列化途径，HiController可以反序列化得到这个HiServiceImpl代理并用HiService接收。
   在调用HiServiceImpl代理对应的HiService方法时都会通过RPC规范去掉用远程RPC框架的东西，再invoke远程HiServiceImpl里的方法
   以上纯属个人理解，未看过源码，纯属猜测。

*RPC不一定是用tcp协议也有用http协议的，但大多数会用tcp协议用socket，性能会比较好。

？在一般RPC框架中，每一个服务（service）实例都用一个线程池线程去处理，如果这样服务多的话不是非常占用资源？ 
 Socket socket=serverSocket.accept(); //监听服务
 executorService.execute(new ProcessorHandler(socket,service));//通过线程池去处理请求


*zookeeper
 分布式过程中出现的问题：
  *协议地址维护：一个服务的集群或多个服务都需要有地址，这些地址多了就难以维护，就需要一个服务器
  *负载均衡，请求一个服务，而这个服务是集群，则需要进行负载均衡，进行合理的转发请求
  *服务动态上下线感知，一个服务的集群或多个服务，他们上线或宕机都需要被客户端所感知，需要通知到位。
  *分布式时共享资源调用问题：多线程是线程间共享资源安全问题，而分布式则是进程间的共享资源安全问题。
  *三态问题：除了事务中的成功与失败状态外的未知状态，可能由于网络通信、延迟等原因造成的。
  *数据一致性，应用集群中各个节点数据保持一致，保持同步
  *保证一些一次性远程调用只在一个应用集群节点执行。
  *应用集群中一个节点挂了，其它节点如何接替它的任务。 
 解决方案：
  *利用zookeeper的数据存储方式以及特性解决分布式过程中出现的问题（分布式协调服务）
  *由于作为分布式环境下的协调者，所以要用集群和一些特性来保障zookeeper的高并发高可用。
  *分布式服务在zookeeper集群上注册，则这些注册数据在这些集群节点间的同步是个问题（增强版2pc来解决）。
 zookeeper特点
  *树形结构存储，例如一个orderservice存储在一个节点上，而其集群中每个服务器的地址存储在这个节点的子节点
   底层是基于ConcurrentHashMap的一个数据存储，包括以下类型：
    *事务日志，每个事务请求都会记录日志，一般这些日志会单独挂载在磁盘上而不放在临时目录里
    *快照日志，其实相当于对数据的一种备份，可以通过它恢复数据。
    *运行时日志，在运行时产生的一些日志
  *zookeeper中心化， 就是leader-follower模式集群，这时候就出现了读写分离，leader选举等一些问题。
  *zookeeper树形节点特性（每个节点都叫znode）：
   *同级节点唯一性，和windows的文件夹文件的结构特性一样，同一层目录下的文件夹或文件名不能重复
   *临时节点特性,一个客户端连接zookeeper服务后创建了一个临时节点（临时节点不能有子节点），在会话结束后，该节点会自动删除
   *有序节点特性，通过命令可以创建一个节点下的有序子节点，这些子节点会有一些特性，如有序....？后续补充下。
   *节点要逐层删除，不能删除一个目录，只能逐层删除
   *持久化节点，和临时节点相对
   *节点监听，客户端可以订阅节点的相关事件watcher，当节点产生相应的变更时会触发客户端相应的操作。
  *watcher特性
   特点：当数据变化时会产生一个watcher事件，发送至客户端。但客户端只会收到一次通知，如果数据再变化，则客户端不会再
         接受到消息。相当于是JQquery的一次性事件。如要永久事件，则需要循环去注册事件。 
   绑定事件的3个操作：getData、Exists、getChidren
   如何触发事件：凡是事务操作都会触发事件
   事件类型：None(-1)、NodeCreated(1)、NodeDeleted(2)、NodeDataChanged(3)、NodeChildrenChanged(4),注意各个事件触发的时机    
  *zookeeper集群角色
   *除了一般中心化集群的leader、follower以外还有一个observer
   *leader负责事务请求（zookeeper节点增删改查），投票选leader
   *follower负责非事务请求（查），事务请求会转发到leader去处理，投票选leader
   *observer增强集群性能，增强查，功能基本和follower一样，但不进行事务投票和leader选举投票。
  *客户端与zookeeper建立连接过程中的几个状态：
    NOT_CONNECTED,CONNECTING,CONNECTED,CLOSE
    当连接成功后为CONNECTED时，如果断开了连接，会变成CONNECTING状态，此时在尝试n次重连后连上就是CONNECTED，否则是CLOSE
 zookeeper节点事务提交过程（增强版2pc协议，二阶提交，即分两次处理）：
    当leader节点收到客户端事务请求（增删改）生成zxid，它会给所有follower发一个要提交事务的携带zxid的消息（proposal），
    follower接受到消息会将这个事务写到本地磁盘并返回一个同意的ack给leader。当超1/2的节点同意时，leader通知
    包括自己在内的所有节点提交事务（即发起commit请求）以及将事务提交成功结果返回给客户端。还有同步给其它节点。 
 zookeeper奔溃恢复（当leader挂了或leader失去过半follower联系即崩溃）（用zab协议解决）
    在上述事务提交过程中，如果有的follower已经收到commit请求而有的没有，此时如果leader挂机，则此时这个事务已经有被某一个
    follower提交了，所以是不能丢失的。 如果在leader还没发起commit请求前就挂了，则这个事务消息要被丢弃。
    zab的设计思想：1.当有的follower接收了commit请求并提交事务而有的没有，此时有提交事务的follower的zxid会最大。
                   2.zxid是在新产生leader后生成的64位数，高32位代表epoch（年号，即新的统治时期），低32位表示消息计数器。
                   3.zxid最大会被选为leader，因为它代表了当前节点的事务是最新的，数据是最新的。
 zookeeper的leader选举：
    影响因素：
     zxid最大会被设置为leader，zxid包含epoch和计数号两部分。这个事务id越大表示数据越新。
     myid越大权重越大
     epoch越大权重越大，每一轮选举epoch都会递增。
    选举过程：
     选举开始时每个zookeeper都会将自己的zxid、myid、epoch三项数据广播给其它zookeeper。
     每个节点收到其它节点的三项数据，依次检查zxid，myid并进行投票
     统计投票
 zookeeper实际应用场景：
  *当一个服务集群，如orderservice，会有一个orderservice节点和多个集群点地址子节点（临时节点），当orderservice中一台挂掉，
   其对应的zookeeper临时子节点也会删除，此时会有通知到对应有订阅通知的客户端（orderservice的消费者）。
  *配置中心，如应用有很多properties文件就可以通过zookeeper管理，当znode产生变更会通知到客户端（properties使用者）
  *负载均衡，kafka集群可以在zookeeper上注册有序节点，此时节点序号小的为leader，当leader挂了又通过zookeeper又重新选举leader
  *注册中心，如rpc的注册中心过程：
   *服务端在zookeeper为serviceX服务创建一个节点，底下临时子节点对应一个服务主机地址，如addrA、addrB...
   *客户端通过zookeeper获取所有serviceX服务的子节点，并通过zookeeper提供的负载均衡策略选出一个来使用，如选到addrB
   *服务端和客户端通过zookeeper进行注册、获取、负载均衡，再加上动态代理等技术就可以实现高效的RPC调用
   *客户端还可以监听serviceX服务的子节点增删，以此来更新本地内存对应serviceX的地址列表addrA、addrB、addrC....
  *分布式锁，利用事件watcher等特性进行实现。有2种方式：
   羊群效应方式：在zookeeper创建一个锁节点，所有客户端通过zookeeperApi去监听锁节点增删，一旦锁节点删除，所有客户端会再去抢锁（即抢注），抢到者即拿到锁。
   依次监听方式：每个客户端再尝试拿锁时都去抢注创建一个临时有序子节点，所有子节点只监听它前面节点的增删，最小节点则认为是拿到锁，当最小节点释放锁，
                 则第二小节点会监听到并去拿锁，以此类推。即再抢注环节，所有客户端的先后顺序已经排好，这应该就叫做公平锁。而羊群效应则是非公平锁。
   分布式锁假想应用：在销售抢单过程中，通过请求创建zookeeper的临时有序子节点，如果抢到第一子节点的人进行业务处理，即抢到单，将单保存再该人名下。
                     此方案还可将zookeeper请求改为单独的API，前端每次抢单前都去请求API，拿到权限再去请求真正的业务。不安全，但对于内部后台系统问题不大。
 zookeeper实操点：
 集群安装、客户端zkClient.sh常规命令操作、集群下个点的数据一致性（数据同步）、更新数据时的版本号
 watcher测试（用一个客户端连接并用get 节点名 true，这个命令就是开启watcher，然后再开一个客户端进行数据修改）、
 sh zkServer.sh status查看zookeeper状态、查看zookeeper的epoch用命令vim zookeeper/version-2/currentEpoch
 利用javaAPI调用zookeeper增删改查，事件。 
 注意：
  *当使用get命令去查看zookeeper的节点值时，会有一些当前节点的信息，如cZxid、mZxid等
   cZxid是节点创建时产生的id，mZxid是节点修改时产生的id，pZxid是子节点变更产生的id
   cversion是子节点的版本，dataVersion是节点值发生变更的版本，aclVersion是节点权限变更的版本，这些版本都属乐观锁
   ephemeralOwner当前会话的信息 
   dataLength节点值数据的长度
   numChildren当前节点下子节点的数量 
  *zookeeper每个节点建议只保存少量的数据
  *zookeeper事务请求（增删改）都会转发给leader，而读请求可以放在任意节点
  *磁盘的读写速度决定了zookeeper的性能。
  *Mic在讲zookeeper的2pc处理事务的过程时，这个事务是指zookeeper数据的增删改事务
  *看zookeeper的事务日志要用mic课程上讲的一个命令
   03.分布式专题\04.分布式协调服务\录播视频\第二次课\20180606_了解zookeeper的核心原理（下）.vep  在11:12处
  *特别注意javaAPI调用zookeeper时，sessionTimeout不能过小，否则在操作会出错，可能是中间有断开重连发生
  *zookeeper在扩容时比较麻烦，需要将所有机器停机，做扩展配置再启动。或逐台机器配置重启。
  ？zookeeper方面面试题在哪里




*dubbo （具体看学习笔记、官网、博客园收藏《dubbo用户指南-总结》）
 *分布式中遇到的问题（其实就是服务治理问题，而dubbo就是一个服务治理工具）：
  *服务地址维护
  *服务被请求时负载均衡
  *服务请求限流/容错/降级
  *监控
 *常用配置（只列出其中几个）：
  *注册中心配置,dubbo支持的注册中心zookeeper、redis、multicast、simple。支持多种类型注册中心同时使用，这里说的不是集群。
           *dubbo在zookeeper上注册的节点结构大致如下
            -dubbo
              -com.gupao.userService
                -consumers
                  -...
                -configurators
                  -...
                -routers
                  -...
                -providers
                  -...
  *缓存配置，dubbo的消费端可以配置服务列表的缓存，避免每次都去请求。？这个缓存的调用和维护时机后面讲
  *协议配置，dubbo支持的多协议：rmi、hessian、webservice、http、thirft、dubbo
  ？hessian是http协议是否说明app等其它客户端也可以直接调用
    网上资料回答是肯定的（Hessian：使用HTTP协议，允许穿透防火墙，使用自己的系列化方式，支持JAVA、C++、.Net等跨语言使用。）
    《dubbo组成原理-http服务消费端如何调用》、《Dubbox的介绍和简单示例》 https://wosyingjun.iteye.com/blog/2320127
    实际上dubbo服务的调用是远程过程调用，就必须有一个代理做发送请求及序列化等工作。而所谓的http协议只是在通信时的协议。
    而并非真正能直接用浏览器进行调用。 如果非要实现这样的功能，可以用dubbo的泛化调用来做一个统一网关，或用当当网的dubbox
  *启动检查配置，dubbo服务的循环引用时启动时会报错，此时可以设置check="false"，启动不检查依赖服务是否启动
   ？dubbo怎么通过zookeeper配置负载均衡的策略的。默认是随机负载策略
  *服务集群容错配置（cluster这是分布式面试常有）
   *由来：在分布式环境下serviceA调用serviceB调用serviceC，如果serviceC出错或不可用，则会导致serviceA、serviceB阻塞住。此时就需要一种容错机制
   *容错机制：failsafe等6种，通过cluster属性配置  ??这里需要补充学习下http://dubbo.apache.org/zh-cn/docs/user/demos/fault-tolerent-strategy.html
      *详见CSDN收藏《Dubbo 的集群容错模式：Failback Cluster》 https://blog.csdn.net/u011642663/article/details/81949941
      *这部分内容主要要去看各个容错处理Invoker的doInvoke实现，如FailsafeClusterInvoker#doInvoke
      *在客户单调用服务端时，（如超时），则客户端报错，但服务端的代码有无执行并不知道或者说是否执行成功并不知道，
       此时就需要服务端按照业务进行相关处理。如addUser()则需要先查询在执行insert。 而客户端对于报错也要进行相应的处理。
       可参考 https://blog.csdn.net/shenhaiwen/article/details/73331193 
      *客户端调用服务端时，如果服务抛出异常，则dubbo会把异常捕捉转移给客户端去抛出，所以服务端就不会报异常。而这种情况
       也算是客户端调用成功了，相当于成功返回了异常。 所以如果cluster="failover" 则不会再重试。 
      *failsafe情况下会把错误吞掉，然后返回给客户端一个null结果（源码里其实是返回一个没有初始化的new RpcResult()）。	
      *需要注意所有服务端的Throwable或RpcException异常都会在Cluster层转为RpcException并向上抛出，所以Mock这层也是接收到RpcException并处理
   *配置的优先级别：消费端和服务端都有相同配置的情况下，消费端较高。如都配置timeout，则以消费端为准。
    1.消费端>服务端
    2.方法配置>接口配置>全局配置
   另外一个服务的配置可以具体到这个服务的具体方法中，即可通过<dubbo:method>进行配置
  *服务集群的降级配置（mock）
   *MockClusterWrapper通过这个包装类去实现降级的拦截
   *场景：比如一页面有算法推荐职位，当推荐服务出错，则web层就直接返回给页面一些默认的数据或静态的数据。 此时用户看到的并非真实算出来的推荐。
         再如在大促销活动前，将一些非核心功能关闭（并且给用户一些友好提示），以保证核心功能在当前硬件环境下高可用高性能。
         加验证码、12306在不同地区分时段分车次开放购票
   *目的:为了保证核心服务可用。当在经过容错机制处理错误后可能自己吞掉错误，也可能交给服务降级mock去处理。
   *类型：自动降级、人工降级。
   *dubbo的mock：降级方案的配置。如服务端Service1实现IService1，然后消费端配置一个mock="ServiceMock"实现了IService1的本地类，当消费端调用
                Service1服务时如果出错，则转而调用ServiceMock的实现，这就达到了所谓的服务降级。
		注意，如果摸个服务访问流量超限制，这种情况是无法通过dubbo服务降级处理的
                ？？但是服务多的话不是要一个个配置降级方案，那不很多。一般是一个个配置，但若是一些公共降级其实就相当于统一拦截，可在nginx层面去拦截。

 *SPI机制：插件的一种规范，是dubbo框架的一个重要机制。
     *java SPI机制
 	1.配置META-INF/services/接口全路径文件
   	2.按照全路径对应的接口写对应实现类
	3.使用ServiceLoader.load(Person.class);加载实例
     *dubbo SPI机制，是自己的插件规范，每个可扩展的地方都称为"扩展点"（Extension），和spring的ioc容器，依赖注入di异曲同工。 
        *起步：引入dubbo，然后通过按照dubbo规范通过ExtensionLoader.getExtensionLoader(Serialization.class).getAdaptiveExtension()调用做入口
        *几个重要的类概念（假设扩展点接口IA，对应实现类有A1、A2）：
	  ExtensionLoader<T>：是一个泛型的类，主要用于加载和实例化A1、A2，如果A1的属性也是扩展点则会用injectExtension()方法做依赖注入
			      其中用到ExtensionFactory的适配器实现类AdaptiveExtensionFactory，它的getExtension(Class<T> type, String name)
			      就是通过名称name获取指定的扩展点实现类，而AdaptiveExtensionFactory内部维护了一个factories集合用于存储扩展点的
			      所有实现类实例。总而言之，扩展点接口有多个实现类，而扩展点的适配器是用于从多个实现类中进行适配或选择其中一个
			      具体实现类的角色，而Wrapper包装类在适配器之前对实现类进行的一层包装。
			      总的过程：对应扩展点的ExtensionLoader加载器初始化时就会去加载对应的Class供以下步骤使用。
					每个要加载的扩展点接口类型都会去实例化一个ExtensionLoader<IA>对象并存储在ExtensionLoader静态字段中，
                                        而IA的实现类如A1、A2都会存储在ExtensionLoader<IA>实例中。 在依赖注入过程中，会通过ExtensionFactory
                                        的实现类去创建所需要的依赖实例，其实还是调用ExtensionLoader中相关的具体扩展点加载器如ExtensionLoader<IB>
                                        所以只有调用getAdaptiveExtension()或getExtension()才会真正去创建所需要的扩展点实例，并执行Aop和DI逻辑。
					以上一系列加载逻辑其实就是用扩展点时再加载Class并生产对象并缓存，而且是单例。因为很多地方都会用到扩展点
                                        所以代码中都是用double check来保证所有生产东西的单例，这点值得学习。
          IA对应一个ExtensionLoader实例,在这个实例会去缓存IA的实现类A1、A2的class
          IA$Adaptive：IA实现类的适配器，用于适配具体的实现类以供开发者调用，比如适配是根据程序运行时的url参数对A1、A2的判断选择其一的过程。
		     在ExtensionLoader实例中可以对AdaptiveExtension的类代码动态生成和编译（类型形如：IA$Adaptive），创建单例并缓存。
		     也可在spi资源文件自定义适配器则用自定义的适配器。IA中如果@Adaptive放在类上则用自定义适配器，放方法则用动态生成编译。
                     在ExtensionLoader相关操作方法:createAdaptiveExtension()、getAdaptiveExtensionClass()、createAdaptiveExtensionClass()
          	     IA、ExtensionLoader、AdaptiveExtension是1:1:1关系。
		     目前理解的是凡是动态生成的适配器类它都是根据实际注册到注册中心的url里的对应参数进行扩展点实现类的选择和处理。		     
    	  Wrapper类：在定义IA的实现类中，若有一个带IA ia参数的构造函数的，则dubbo认为他是一个包装类，则所有的非包装类的IA的实现类都会被它包装	        
                     其实Wrapper类实现的就是Aop的功能  
	  Directory类：服务目录，其实就是从注册中心去获取对应的服务目录列表，即List<Invoker>,这里的Invoker应该是每个服务对应一个。
	  ExtensionFactory类：用于依赖注入时获取扩展点实现类实例，因为ExtensionLoader<T>实例不过就是加载器，加载的对象自己有缓存同时也有可能放
                              在springIOC容器，但实际上加载器生产的对象也没有放到加载器以外的容器，所以这个功能有点鸡肋或者与设计初衷北里。
	  Invoker类
          Invocation类
        *规约：
             *URL贯穿所有扩展点，自动生成的扩展点适配器的接口IA的方法必有URL参数，以确定真正的底层实现类。
              @Activate也是通过URL参数确定扩展点是否激活（实例化并使用），如一些过滤器类，如果激活即在实现类基础上做过滤包装。
             *凡是有一个带IA ia参数的构造函数的，则dubbo认为他是一个包装类并会进行相应包装
             *凡是类中有成员变量也是扩展点并且有相应的set方法，则dubbo会进行对应的依赖注入                 	     
	*几个注解：
          @SPI("defaultValue") 表示当前被注解的接口类是通过SPI获取实现，即是一个可扩展点。
          @Adaptive 加在接口类上表扩展点接口的实现类的适配器是在SPI的META-INF资源里自定义的适配器。用到扩展点时实际上是用这个适配器类。
		    因为ExtensionLoader代码里默认就是去取它 ，而加在方法是用动态字节码按一定规则生成的适配器（它通过URL参数决定真正的实现类）。
	  @Activate通过自身的注解参数和扩展点的URL参数做对比以确定扩展点是否激活，如一些过滤器类，如果激活即会在实现类基础上做过滤包装。
	*服务发布过程：dubbo自定义了很多spring的xml标签，并通过ServiceBean(对应的标签为<dubbo:service/>)作为启动入口，进行一系列初始化过程。
		       详见CSDN收藏《Dubbo源码解析之服务发布与注册》 https://blog.csdn.net/laravelshao/article/details/83655652
		       注意：服务发布类调用时序图、Invoker是包含远程方法调用信息和动态代理类的信息类	
		       总之导出服务其实就是创建一个服务的过程，并且以Exporter实例作为载体，在这个载体可以获取方法的执行体Invoker等东西。
		       Invoker里的Invocation封装了执行体相关的一些参数信息。		    
        *服务订阅过程：和发布过程类，<dubbo:reference/>是入口，详见CSDN收藏《Dubbo学习之路（五）：服务消费者发现和订阅服务源码解读》
        		https://blog.csdn.net/jadebai/article/details/80684870
        *Dubbo泛化引用：其实是在消费者消费服务时可以不需要接口实现，而是提供一个通用的实现调用。，详见《Dubbo泛化引用》
                        利用它可以实现一个通用的远程服务Mock框架。
			利用它还可以作为中转站，让app、浏览器等http间接访问dubbo服务。https://www.jianshu.com/p/ff0947529de4
	*思想启蒙：适配器模式、双检查锁实现单例模式、SPI插件、动态字节码和编译、规范、泛型、Wrapper装饰器、缓存单例、
		   程序初始化流程的性能调优优先级应该放的比较低，但是安全的优先级应该放的比较高！			   
 *实操点：
   dubbo发布服务的demo、dubbo服务用hessian和http协议发布的demo、负载均衡配置、粗略看源码（2.5.0-版本，之后）
   服务的Version、mock（设置timeout=1来构造超时执行降级方案）、负载均衡、SPI、
   通过ExtensionLoader.getExtensionLoader(Protocol.class).getAdaptiveExtension()源码来研究dubbo的SPI应用过程、
   async参数设置是异步调用可以做性能优化详见博客园收藏《Dubbox 基本特性之异步调用》、	
   客户端stub参数设置可以对服务进行再次包装过滤，可以做一些容错或过滤应用
   参数验证、
   Router路由规则可以在dubbo-admin平台上设置。
   课程都学习完后去看mytotal和爱定家dubbo代码
   dubbo服务容器启动方式测试
 *注意：
   *分布式服务一般会将服务接口类作为一个单独的jar发布以供消费端使用。
   *dubbo底层是用Netty进行通信
   *dubbo下的服务可以不用打war和依赖Tomcat等web容器，可直接打jar包然后通过dubbo特定代码启动
    注意dubbo支持了spring、jetty、log4j的container容器，用于启动服务的应用。默认spring容器
   *dubbo的RandomLoadBalance算法是权重+随机的算法
   *dubbo中Directory、Router、LoadBalace、Invoker、Cluster（以及Cluster Invoker）的关系其实是服务集群流程的各个节点。
    详见官网说明http://dubbo.apache.org/zh-cn/docs/source_code_guide/cluster.html
   *简书收藏《dubbo一些你不一定知道但是很好用的功能》有RpcContext传递隐式参数等一些功能介绍
   *注意<dubbo:service>的executes、actives、threads、connections设置，他们的区别和关系
 *问题：
  ？？重新学习dubbo的使用再去看官网，有必要再做调试研究 
    ！已重新研究源码和官网
  ？容错和降级同时配置时是怎么样一种表现，还有在事务性服务链链是什么表现，这些应该是比较重要的内容
    ！此问题在可看dubbo官网的源码说明可略知一二，在源码导读-集群/服务调用过程两部分可以知道它的表现形式。
      详见http://dubbo.apache.org/zh-cn/docs/source_code_guide/cluster.html和http://dubbo.apache.org/zh-cn/docs/source_code_guide/service-invoking-process.html
      dubbo官网说服务目录是 Dubbo 集群容错的一部分，也是比较基础的部分，所以大家应尽量搞懂。    
      只mock只有在容错机制抛出PPCException情况下才能接受处理，？这个要验证下
  ？如果有很多个服务消费，那岂不是要配置和编写很多个mock	
  ？双重检查锁定 if (instance == null) {synchronized(）{if (instance == null) {xxxx}}}  单例模式里有
  ？再去将dubbo学习的18点内容复习下，老师提的内容要点。
  ？淘淘项目服务端pom里排除了netty，那在默认protocol=dubbo协议情况下  duboo协议底层又是通过什么通信？ 
  ？dubbo课程像没有讲到线程模型，等多线程编程学完再重新回到dubbo学习下。
  ？<dubbo:service>的executes、actives、threads、connections、accepts设置，他们的区别和关系
  ？Router路由规则要学习下
 *常见应用问题及解决方案：
  *利用filter参数配置解决具体服务的拦截功能，比如调用次数或时间的统计。？？filter的使用和原理还要稍微看看。
  *mock做降级
  *async让客户端做异步调用，做性能优化。需要结合RpcContext.getContext().getFuture();
  *executes、actives、threads、connections做线程和请求数性能优化
  *多注册中心的意义，如果在国内外两个环境部署一套消费者和服务者，地理位置造成网络很远，此时就可以用两个注册中心将两个环境隔离开。 
   但是有一些公共的服务，又是需要国内外共同使用的，此时就可以将公共服务注册到两个注册中心上去。
   如果用group去区分国内外环境其实是有问题的，因为注册中心无论放在国内或国外对于另一个环境都是远距离传输，速度显然不行。

*MQ  
 *分布式队列消息的应用
  *应用功能的解耦，如用户注册功能会附带发送邮件，新人礼包等操作
  *流量消峰，如秒杀活动，会先把所有请求都写到MQ消息队列中，具体处理秒杀的业务服务再去订阅这个消息
  *异步化，如有些耗时业务不直接处理，等资源空闲时在处理
  *业务可扩展性，如增加一个用户注册相关的附带操作业务，可以直接订阅用户注册的消息即可实现。
  *实现数据一致性

*MQ相关概念
 JMS java message service  是一套java消息队列的规范API
 AMQP
 MQTT
 MOM 面向消息的中间件

*2种模型
 P2P模型 点对点
 Pub/Sub模型 发布订阅

*注意：MessageConsumer.receive()是阻塞的，即只有接收到消息后才会往下执行
       也就是说消费者可以使用阻塞的receive或者非阻塞的监听方式去获取到消息

*持久化机制，保证消息可靠性，这具体要研究下用法？
 可以设置ActiveMq持久化到磁盘或者数据库上，这时可能需要mq服务器有一些性能资源的开销。

*持久化订阅，即客户端一次性注册一条持久化订阅然后关闭客户端，此时服务端发送一条消息到MQ，当在打开客户端去获取持久化订阅的消息是能获取得到的
 要求在服务端和消费端都做相应的持久化设置

*消息发送的方式（可通过mq连接的url参数设置，也可通过代码设置）
 同步发送，会有性能开销，因为阻塞，但安全性高。 非持久化并且非事务的消息默认采用同步发送。
 异步发送，和同步相反，非持久化消息默认采用异步发送。
 *开启事务的消息都是异步发送

*Broker 相当于mq的中控中心，负责消息保存订阅、客户单连接等。

**MQ消息的应答方式（ACK_MODE）和应答类型（ACK_TYPE） 详见https://www.jianshu.com/p/c2bd409cadf2
 注意以下代码 客户端循环非事务消费10条消息，如果在第9条消息执行acknowledge()签收，则前面8条也会被签收，则只剩最后一条没被签收。
 因为receive()会将接收到的消息放到待签收的缓存中，一旦有执行acknowledge()则连带前面的消息都会签收。这应该就是所谓的session级别
 for(int i=0;i<10;i++) {
                TextMessage textMessage = (TextMessage) consumer.receive();
                System.out.println(textMessage.getText());
                if(i==8) {
                    textMessage.acknowledge();
                }
            }


*非持久化存储是存在内存 

*消息发送的过程原理（看流程图会比较清楚）
  pruducerWindow应该是要存异步发送的消息缓存空间，所以它要保证空间足够用才能进行异步发送。
  这个缓存空间由activeMq配置 systemUsage节点相关参数进行设置

*5种持久化机制
 kahadb  默认，事务日志方式
 jdbc 就是数据库存储，支持Oracle、MySQL...  ()
 Memory 内存，不配置持久化的时候就是内存方式
 LeavelDB  性能高于kahadb的方式，官方不推荐，原因不详。可以实现主从....
 JDBC with ActiveMQ journal 由于jdbc性能不算很很好，而这种方式是采用日志文件缓存然后同步到数据库。

*消息消费流程（看流程图比较清楚）
 2中消费方式，同一session下不能同时使用这两种方式
 received
 MessageListenner

*客户端在发送或消费消息时，在ack确认之前会放在一个列表中。

*preFetchSize 一个设置参数。消费端在消费消息时候其实会预先获取preFetchSize条消息，然后一条条消费，相当于是提前批量获取，以减少交互。
 如果有2个客户端同时开启，有4000条消息可消费，而2个客户端都设置preFetchSize>=4000,此时必定有一个客户端获取不到消息。


*optimizeAcknowledge 开启优化ACK，相当于批量提交，批量应答的。注意和preFatchSize配合使用。
 可以减少消费消息阻塞和网络通信开销，会出现消息重复消费！！！

*消息重发机制（重新接收）： 6次重发后就发一个posion_type标志此消息有毒，然后这个消息就丢到死信队列（ActiveMQ.DLQ）。
 可以设置重试间隔时间，一般是设置间隔时间递增。
 死信队列也是消息队列，也可以被消费，可以配置它的策略。可以针对所有队列也可以针对某个队列设置策略。

*broker网络连接（高可用高性能解决方案），多个broker通过网络链接在一起（不算是数据同步）。通过networkConnector配置实现 
 它是一个单向通信，如两个activieMq a和b，a配置了网络链接而b没有，则客户端链接a可以消费到b上的消息，而客户端链接b却消费不到a的消息
 所以要达到a和b都能消费到各自的消息就必须在ab两个服务都配置网络链接。
 ？消息无法回流，是单项流动，无法再次回流。可以参数设置回流策略，replyWhenNoConsumers="true"
 如果activimq节点需要很多呢？ 

*activeMq的集群，利用zookeeper的有序节点实现leader选举。
 和持久化策略相关联。
 官方默认是kahaDB，所以官方推荐在集群中使用kahaDB文件共享方式来达到集群中数据的一致。kahaDB会有锁的机制保证读写唯一。
 如果是jdbc方式，则jdbc会在对应数据库有一张lock表用于提供锁，保证集群的读写唯一。
 
 
*ActiveMq适用于并发量小

*ActiveMq优缺点
 缺点：吞吐量低，无分片（数据量大就有问题）
 优点：TPS要求上低的话，开发易上手

*实操点：
 各种jdbc方式的持久化配置使用，消息重发、broker网络链接。

*URL驱动  其实就是通过URL及其参数和协议来做接口的不同实例化，相当于做多态

*装饰器模式可以使得功能按领域划分，便于维护和扩展


？学员问,高并发下如何保证消息不被重复消费,Mic回答说不能保证，这是怎么说。

？BlockingQueue的学习，应该在多线程部分会涉及吧。在dubbo容错方案ForkingClusterInvoker设置并行请求时源码涉及。


*Redis 
 *结合淘淘和咕泡的文档和中文官网进行学习实践。
 *5种数据类型中的list，提到了“双向链表”：每个数据在内存中存储位置是不连续，但每个数据节点都存储了上一个和下一个节点的指针。
  双向链表在插入和删除复杂度低，但是内存开销大。“压缩列表”：和双向列表相反，内存中是连续，内存空间小，插入删除复杂度高。
  redis3.2前都是用上2种一种，redis3.2+就是quicklist，是上2种的综合。

 *守护进程的方式运行：守护进程一般在系统启动时开始运行，除非强行终止，否则直到系统关机都保持运行。
  常见的守护进程包括系统日志进程syslogd、 web服务器httpd、邮件服务器sendmail和数据库服务器mysqld等。
 
 *fork一个子进程：相当于复制一个子进程，和github的fork项目仓库差不多。 

 *2种持久化方式
  rdb快照，在一些自定义或系统自身的条件下会执行快照，此时可能会阻塞主线程造成其它客户端不能访问redis
  aof文件，没次操作都写入操作日志文件到磁盘，性能不会有大的影响。但是文件会一直增大，
           特别是当有一些冗余操作如执行"set foo 1"再执行"set foo 2"，但redis会有优化方案：重写aof文件。

 *内存回收策略

 *Lua脚本相当于一段sql语句集或存储过程，可以让redis一起执行多个命令语句，从而减少多个单语句在网络传输中的消耗。执行lua脚本实例如下：
  如 EVAL   "return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}"     2         key1      key2     first      second
     [命令] [脚本内容]                                [参数个数]  [参数名1] [参数名2]  [参数值1]  [参数值2]

 *lua脚本可以由redis客户端发送到redis服务端执行并保存，其它客户端可以直接复用。  

 *redis是单线程，这是就只能用到CPU的一核心，如果要充分利用服务器CPU的多核，可以在同一台服务器上部署redis集群。

 *redis是通过NIO实现异步，即多路复用。

 *Redis存在最终一致性，原子性问题。 例如：age=1两个客户端同时访问Redis 执行age++;最后age可能等于2或3
  在单体redis中，可以通过MSET命令保证多个命令同时成功或失败，保证最终一致性。但是在集群下这个命令无法保证一致性。
 解决方案：使用lua脚本，例如上面的age++;命令，把这个命令编写在lua里面，两个客户端AB都执行过lua而不是直接执行命令。
           此时A执行lua时是不受B的影响的，并且等到A执行完后，B执行的也是同样的lua，因为Redis可以执行过的lua保存起来。
 问题：如果lua脚本复杂，执行时间很长，则其它客户端连接会被阻塞掉并返回错误。用script kill去终止lua脚本的执行

*Nginx
 *nginx.conf的server_name和location配置规则需要补充学习。 
  server_name和location的匹配是相互独立的，如果www.s1/location1匹配到server1但是找不到location1的匹配则会报错，而不会去server2里看有没有location1
  server_name匹配优先级：完全匹配>通配符在前>通配符在后>正则>listen配置项后有default或default_server的>前面的都没匹配到则找到listen端口的第一个server
  location匹配优先级：  
 *Nginx安装第三方扩展模块需要重新编译，在第三方扩展模块添加后要进行编译时，原来编译的相关的参数也要加上去，不能省略。
  为了不覆盖原有安装后的相关配置（如：nginx.confg），可以将编译后objs/nginx目录拷贝到原本安装sbin目录（如：/usr/local/nginx/sbin）

 *C语言的应用，在linux下 用make命令是编译，make install命令是安装的意思。

 *./nginx -V 查看nginx版本及相关信息，如扩展模块信息。在添加新的扩展模块时，可通过此命令查看当前现有的一些扩展模块。

 ？学习要点：
  ？要学习常见的Nginx扩展模块：状态统计http_stub_status_module、限流ngx_http_limit_req_module
  ？proxy_pass模块下的各种常见参数配置，如proxy_set_header Host $host;proxy_set_header X-Real-IP $remote_addr;等等
    proxy_set_header相关设置可以让目标服务器从nginx那边获取到真正客户机的一些请求信息，而不是获取nginx的请求信息
  ？负载均衡中ip_hash策略的应用场景，详见csdn收藏 https://blog.csdn.net/xqhys/article/details/81788358
    其实可以举例917使用又拍云，我们做了一层服务器缓存，此时就要求根据ip或url进行hash，让客户端相对固定的访问统一个真实服务器。
  ？io 模型，epoll、select....是什么鬼
  
 *nginx.conf里面也可以用include 来包含其它的配置文件，从而达到分类治理的效果。

 *用nginx或tomcat做静态资源服务器时，静态资源的header里会添加ETage和Last-Modified两个信息以供浏览器决定如何做缓存，如：
  ETag: "5b0ce6b0-570b"
  Last-Modified: Tue, 29 May 2018 05:35:44 GMT
  但实践中一般会指定明确的缓存策略，如设置expires为1d。 597的静态资源是设置expires为30天

 *nginx中的gzip压缩是可逆的，无损压缩，但是会消耗一定的CPU资源，这个如何去权衡。
  图片、音频、视频用gzip压缩的后大小基本不变，只能做有损压缩，如降低分辨率和质量。或者可以用第三方的服务应用。

 *nginx进程模型：一个master进程加多个worker进程组成，worker进程是从master进程中fork出来的。
  通过ps ef|grep nginx 可以看到nginx默认开启了master和worker两个进程
  工作进程数通过worker_processes设置，一般建议设置为linux的CPU核心数
  worker_connections=1024说明一个worker进程可以处理的连接数，即并发数，理论上如果有3个worker进程，则总并发可达1024*3

 *fork进程是UNIX关于进程管理的一个术语，本质是新开一个进程，但是不从磁盘加载代码，而是从内存现有进程复制一份。

 *如果nginx的并发/吞吐量不够用了怎么办
  *简单方式：在nginx做集群，然后dns做轮询
  *昂贵方式：nginx做集群，然后F5做负载均衡
  *复杂方式：dns做地域性的解析，指向当地的机房。


*NIO 先看博客园收藏《Java NIO：NIO概述》，在看咕泡课程笔记，再看博客园收藏《Netty序章之BIO NIO AIO演变》
 *同步/异步，阻塞/非阻塞概念可参考简书收藏《深度解读Tomcat中的NIO模型》
 *其中司机-售票员-乘客 可以很好的解释NIO和BIO的区别。BIO有点像每站必须停的公交，而NIO有点像中长途巴士，根据乘客要停的地方在停。
 *BIO模型下，如下代码ServerSocket需循环接收到客户端Socket实例，然后new Thread()去处理。这时候对于客户端是阻塞的，
  while (true) {
     Socket socket = serverSocket.accept();
     new Thread(new ServerHandler(socket)).start();
  }
 *NIO模型下，客户端请求服务端时并留下事件，而服务端用一个线程去轮询这些事件，当数据准备好了就触发对应的事件。 
  这就是同步非阻塞，同步体现在事件轮询，非阻塞体现在客户端不必等待服务端。
 

 *BIO是面向流的，而NIO是面向Buff的。

 *堆外内存：即不被jvm管理的内存空间。堆内内存则相反。

 *系统调用，我们的java应用要调用到操作系统内核的api时候就叫系统调用。

 *操作系统的内核是管理我们的内存，操作CPU、管理文件系统等主要资源的程序。
  而操作系统就是由内核和外围的一些程序组成的。
 *内核态，只能由操作系统内核来调用的资源，如文件系统。
 *用户态，和内核态相反。

 *系统调用的时候，一旦应用程序调用到内核的api的时候，就会处于阻塞状态。

 *BIO 同步阻塞
 *NIO 同步非阻塞

 *阻塞是对于客户端，同步对于服务端。 这里的客户端和服务端，可以理解为应用程序和操作系统内核。

 *NIO的chanel是双向的，而BIO的流是单向的。

 *NIO的buff简单理解成为一个数组。

*NIO理解可以参考博客园收藏《支撑Java NIO 与 NodeJS的底层技术》

*堆内内存 是由jvm管理的内存  堆外内存是不被jvm管理而是由操作系统管理的内存

*个人理解同步与异步，阻塞与非阻塞
 *对于服务端来讲是同步与异步，也就是说服务端如果"停滞"了则为同步，否则异步
  对于客户端来讲是阻塞与非阻塞，也就是客户端如果"停滞"了则为阻塞，否则非阻塞
  注意，对于底层来讲java进程和系统io内核api来说，java进程为客户端，而系统内核为服务端。
        此时对于java进程和系统内核交互时，分为系统内核有数据准备阶段和数据赋值两个阶段。
        在数据准备阶段，java进程请求io数据时如果能立即返回则为非阻塞，反之为阻塞。
        在数据赋值阶段，系统内核如果是立即处理，则为同步，否则为异步。
        这个过程可以结合大白老师的nio_demo进行理解。
  *宏观的看：有客户端，服务端，系统内核3方，客户端和服务端其实都有一个os系统内核。这两个系统内核通过io交互然后把数据通过事件推给客户端和服务端。

 *BIO是面向字节的，就是只能一个字节一个字节操作
  NIO是面向buff的，就是可以块块数据进行操作

 *java是不允许直接操作地测内存相关的东西，但是有一个unsafe操作类可以让我们操作。 程序员一般不用。但是一些Nio框架会用到。

 *Nio的buff相关概念（详见csdn收藏《JAVA NIO缓冲区(Buffer)------ByteBuffer常用方法详解》）：
  capacity 整个buff的容量
  position 读或写操作时的起始指针位置
  limit 读或写操作时的限制长度
  flip()当写操作时要转为读操作时，通过flip()方法将limit设置为position的值，然后将position指针调整到buff首位即0的位置，从而达到可以读取已写数据
  rewind() 似乎和flip类似  具体百度下或直接看方法源码即可清楚 
  marke


 *Nio的selector也有点像rpc一样，其实是在服务端和客户端的一个代理，用于屏蔽细节。
  对于客户端和服务端把相应的事件handler注册到它的selector上，而服务端的事件由操作系统去触发，然后顺理成章的触发客户端的事件。
  简单的比喻：clientA、clientB找server下订单，server去找系统内核os工厂真正制造数据产品dataA和dataB。
  server有一个线程轮询的问dataA和dataB好了没？ 如dataA好了，server就打电话给clientA说好了，把dataA通过事件传递给他。
  注意：一个selector实例既可同时注册客户端和服务端的channel的相关事件。它其实是一个事件容器，当注册的事件的数据准备好了，操作系统会将对应的状态
       设置为true（如：selectionKey.isWritable()为true），而开发人员只要轮询selector的selectionKey的状态即可根据状态进行相应的读写等操作。
  

*注意socketChannel.write(writeBuffer);并不一定会将writeBuffer里的内容一次性写入到socketChannel中，

*Arrays.copyOf(byte[] original, int newLength)可以拷贝原数组的指定长度的元素

*Netty4.x版本是比较成熟稳定的版本，使用的是NIO，而Netty5.x用的却是AIO，但是由于操作系统支持及性能表现没比4.x好，所以主流都是用Netty4.x

*Netty学习 找不到大白的相关笔记，可学习网上
 博客园收藏《netty入门（一）》 https://www.cnblogs.com/sky-chen/p/10497166.html 这里面有对大白代码的剖析
 教程系列《Netty入门教程——认识Netty》https://www.jianshu.com/p/b9f3f6a16911  （图片显示不出来，执行$('.image-view img').each(function(){$(this).attr('src',$(this).attr('data-original-src'))});）
 博客园收藏《Netty框架入门》 代码部分可不看

*Netty的几个组件
 EventLoopGroup 事件循环器组，它可包含一些线程。 他可以传递给Bootstrap或ServerBootstrap作为主事件循环器组和工作事件循环器
 EventLoop 事件循环器，一个线程可对应多个EventLoop
 Bootstrap/ServerBootstrap 客户端服务端的帮助启动类
 Channel 和Nio的channel对应，有做了一些封装
 Handler 用于非业务和业务的一些逻辑处理，相当于事件的方法体
 ChannelFuture是一个Future接口对象，在channelFuture.channel().closeFuture()代码实际返回的实例还会是一个promise对象。
 
*网上说Netty需要一段时间才能预热，但是它能够处理比NodeJS每秒多40％的请求。 只是代码量要比NodeJS多很多。

*serverBootstrap.childHandler()和handler()的区别，是面试中常考的一个问题。
 handler是服务端channel接收连接及初始化等相关的事件业务处理逻辑，是与bossEventLoopGroup相关的处理产生的事件。
 childHandler是处理客户端连接生命周期中的一系列事件处理，也就是workEventLoopGroup相关处理产生的事件。

*一般Tomcat默认还是Bio的io模型，可配置Nio 
 使用NIO方式处理并发性能好的前提是 每个请求耗时不能高，但是这样对现有的request response处理要有额外处理。 
 如果不能达到这个要求，用 NIO反而会是整体性能下降。
 现在一般的处理流程： 请求进来，查数据库，执行业务逻辑，渲染，然后返回。整体耗时很长。所以……

*Nio_Demo中serverSocketChannel.configureBlocking(false);实际上就是让serverSocketChannel.accept()方法非阻塞，即同步非阻塞模式。
 如果设置为true则serverSocketChannel.accept()方法阻塞，此时如果serverSocketChannel.regist()内部会判断blocking为true则抛异常。
 即设置为true实际上就相当于BIO的模式，并且serverSocketChannel不能注册到selector上
 注意：serverSocketChannel是可以不注册到selector上的。 个人理解selector是一个轮询载体，也是系统调用过程中所产生事件的接收体

*Nio通信的整体过程：


*netty源码中有些方法是带有0的(如channelRead0)，一般是真正干活的，而不干活的是如channelRead

*netty可以实现3中Reactor模型：单线程模型、多线程模型、主从多线程模型。详见咕泡文档《09-Netty 源码分析之EventLoop.pdf》

*handler实现类上的@Sharable注解主要是为了这个handler可以被多个channel安全地共享。
 因为handler里是业务逻辑代码（如业务逻辑A），而多个客户端channel他们可能在EventLoopGroup里的不同线程，他们要共同访问A，所以A代码要保证线程安全。

*Netty可在任何系统上运行，但对于不同的系统会有不同的折中，Linux系统中的epoll具有高可扩展的I/O的事件通知，Linux上的JDK的NIO则是基于epoll，
当使用epoll取代NIO时，可以使用Netty中的EpollEventLoopGroup取代NioEventLoopGroup，使用EpollServerSocketChannel.class取代NioServerSocketChannel.class。
https://www.cnblogs.com/leesf456/p/6895145.html

*沾包问题：详见CSDN收藏《Netty4实战 - TCP粘包&拆包解决方案（这个文章解决了自己想解决的问题）》

*在快速重连的图解中，HandlerShakeHandler、FastConnectHandler是netty自带的组件

**研究下ChannelFuture和Future接口   juc里线程池操作有使用到Future

*CompletableFuture此接口需要学习下，详见https://www.jianshu.com/p/6bac52527ca4
*RecursiveTask需要学习下
**juc常用的api都需要学习下

*大白老师代码研读 begin-------
？大白老师留的3个问题：
 1.netty服务端默认启动多少个线程，什么时候启动
 2.Netty是如何解决jdk空轮询的bug
 3.netty如何保证异步串行化
？ServerChannelHandler#channelRead问什么能将msg转化为Packet，是不是客户端是直接对象序列化 Packet packet = (Packet) msg;
？项目中是如何解决分包或者粘包问题的
？ServerBoot(Server server, ServiceNode node) 这里的ServiceNode node具体作用和使用。大白只让node做注册中心注册使用，是不是应该让server去依赖node
？GlobalChannelTrafficShapingHandler详见简书收藏《Netty 那些事儿 ——— Netty实现“流量整形”原理分析及实战》
？com.google.common.eventbus.EventBus的作用和使用，它在整个系统中充当的角色是什么
？注意各个服务组件（如路由服务、网关服务）他们是分属不同的进程，因为他们各自启动一个服务进程。
？app等前端是否能够直接查询zookeeper，然后自己做负载均衡？ 
？this.holderFactory = heartbeatCheck ? HeartbeatCheckTask::new : SimpleConnectionHolder::new;这里SimpleConnectionHolder没有无参构造函数为什么还能用new
  这是jdk8的语法，但是感觉有点奇怪，这样不算直接可以访问私有构造函数了？ 
？为什么很多一些对象Xxx需要用XxxHolder进行包装
？一般xxxHolder有什么作用，为什么要做一层包装。一般是做一些简单的逻辑包装
？this.timer = new HashedWheelTimer(...时间轮概念 详见《使用netty HashedWheelTimer构建简单延迟队列》https://www.cnblogs.com/eryuan/p/7955677.html
？学习jdk8的新语法
？心跳逻辑，似乎没有什么特殊的逻辑和作用
  如果heartbeatCheck配置为true，则代码中用了一个定时器去检查连接的状态，并且输出了对应连接的状态信息
？NettyConnection的“读超时”isReadTimeout()是个什么意思
  一旦netty通道建立即对应着一个connection对象，而这时候在一定时间内没有读操作，可以进行一些操作，如关闭连接。
  这些连接上根据读写的状态而进行的一些操作放在连接管理器上处理，如ServerConnectionManager
？ChannelFuture、ChannelFutureListener的使用    
？ChannelHandlerContext ctx; ctx.writeAndFlush和ctx.channel().writeAndFlush的区别和联系
  !详见CSDN收藏《Netty中ctx.writeAndFlush与ctx.channel().writeAndFlush的区别》
？InboundHandler顺序执行，OutboundHandler逆序执行的执行顺序，要做测试。
  大概是读事件按addLast时的顺序执行，而写事件则按addLast时的逆序执行
            
？NettyConnectionServer里 start(Listener listener)的listener研究下
？注意epoll模式的server
？CompletableFuture此接口需要学习下，详见https://www.jianshu.com/p/6bac52527ca4

？LinkedList的poll pop remove peek等方法的比较
  linkeList.remove("a");//删除时如无该元素则返回null
  linkeList.pop();//删除顶部元素，如无该元素则抛异常 和push配合使用，实现堆栈数据结构
  linkeList.poll();//删除顶部元素，如无该元素返回null，和offer配合使用，实现队列

？tomcat是采用io多路复用的Nio吗？ 如果不是则一个客户端请求就要有对应的一个服务端线程。 
  详见https://www.oschina.net/question/1240923_2202821
      https://blog.csdn.net/fd2025/article/details/80007435
      https://www.jianshu.com/p/76ff17bc6dea
  
？为什么DB不能用io多路复用技术，而是使用连接池技术。详见https://www.jianshu.com/p/61079795896b

？明天过下bind()的源码过程、pipeline的结构、启动netty server demo  用shell  telnet连下、复习下传智网络编程tcp3次握手、sync()源码过程
  学习完netty后回头过去看dubbo服务发布过程的源码

？秘钥交换个人感觉只是保证了数据传输的安全性，那骑手客户端在连接推送平台之前应该是要通过业务系统注册登录并获取公钥（也可认为是token）
  此时拿到这个公钥不就意味着可以直连服务端并获取响应的数据了。

？？商家提交消息到 pushCenter，这个消息body里带的userId应该是目标骑手用户的id
？？商家提交消息前先要连接到某台 网关服务器节点（也是连接服务器节点，也是连接管理节点），此时连接暂存map要么是互通的，要么就是直接转发到另外服务器节点，
？？整个推送消息到下发消息的具体过程要理清楚，可以通过tester相关demo进行测试

？编码过程中为什么要把package.body=null;
？push-client属于服务端的sdk，主要可以用来做消息推送 ，甚至可以在Android里用这个sdk来发送消息。 但是ios就应该要做另外的sdk了
？netty的连接如果没有手动断开就应该一直保持着，属于长链接
？connection的心跳检测是判断读超时超过指定的次数就关闭连接。这样的话可以减少无用的连接，当骑手连接被关闭后，有需要再通过握手，秘钥交换等流程建立新的连接。当然连接的关闭和重建是伴随着本地路由和远程路由的更新的。
？看下ping -> pong的具体心跳逻辑

* nioEventLoopGroup.setIoRatio(100);//代表全部线程都用于操作Io的读写，而没有线程用于操作业务的读写？何为业务读写
  !个人理解，在接收连接进来的消息后，由于业务需要，也需要另外的线程来执行任务，此时就会将这些任务放到netty的EventLoop里去，应该是共用线程的目的。
   如代码：task.getExecutor().execute(task);里其实都是获取通道对象里面的eventloop对象
*ConnectionServer#init里所有注册的命令类型都是由客户端发过来的，有点像springMVC的Dispatcher
*6上30分钟
*lion.conf完整的配置在哪里可以查看，其实可以看CC接口类和dabai-vip\conf\reference.conf


*大白老师代码研读 end------- 




？？各类常见分布式解决方案及其问题可看公开课，找启蒙。在学习完基础课后，先对基础再复习一遍，然后找启蒙问题做demo（可简单看公开课）

？com.gupaoedu.vip.distributed.io.niodemo.channeldemo.ServerSocketChannelDemo里还有些代码疑惑，后面有空了解下
  其中为什么socketChannel.write(writeBuffer);并不一定会将writeBuffer里的内容一次性写入到socketChannel中


？明天自己百度下Nio的服务端demo代码的一些疑惑
  自己学习下大白netty的demo代码

？下午传智集合全部练习一遍
  看一遍这个链接并做好intellij笔记  http://www.cnblogs.com/KnightKitt/p/8904001.html
  
--------------------分布式 end--------------------------------


--------------------并发编程 begin------------------------------
*进程和线程的概念，看传智基础课再看咕泡课程，如果再看不懂购买腾讯课堂课程https://ke.qq.com/course/343174
 可参考博客园收藏《Java多线程系列——从菜鸟到入门》

*进程和线程的概念、wait\notify\notifyAll\join方法的使用和原理看传智。
 注意这些方法的调用对象。wait\notify\notifyAll是lockObj，join是threadObj
 

*notify 仅仅通知一个线程，并且我们不知道哪个线程会收到通知，然而 notifyAll 会通知所有等待中的线程。
 notify、notifyAll要在synchronized里进行使用，这样才能找到锁
 注意lockObj.wait(timeout)重载是指当超过了指定时间，则当前线程会继续加入到lockObj锁的竞争行列，如果获取到就继续执行自己的代码

*threadObj.join()原理看csdn《Java中的join方法原理详解》,threadObj.join()其实是主线程将threadObj的作为锁对象synchronize并wait，知道子线程任务结束

*Condition对象的await()\signal()\signalAll()相当于锁对象的wait()\notify()\notifyAll()。
 Condition对象是和Lock实例lock()方法绑定使用，而wait()等方法是和synchronized及锁对象绑定的。 本质上都是让这些方法找到锁。

*JUC线程池的Future<String> future = ex.submit(...)中的Future原理详见csdn《JUC FutureTask 分析》

*总的说进程管理了应用所需的一些资源，如内存空间、cpu资源等，而线程则是在这些资源范围内去抢占资源。

**假设A为主线程任务，A中有一个耗时操作b。此时可以启用了B线程以提高性能。其中可用join或Callable去保证一些业务的有序性。
 如果A任务最后用到了B的执行结果，则采用Callable
 如果A任务里并没用到B的执行结果，但又必须等B执行完才能结束A线程，则采用join

*阻塞队列LinkedBlockingQueue的使用。 有一个使用调用链套路详见mic-vip\2018\20180810-并发编程第一节课\Demo.java
 线程池ExecutorService的使用

*线程的6种状态，注意调用哪些api会影响它们的状态改变。如:Thread.sleep(100)会使当前线程进入超时等待状态。

*线程的启动和终止，常问的面试题
 方式1：threadObj.stop()是暴力终止，已过时，有点像linux里的kill命令。有些资源可能还没释放或者还有一些地方在用此线程。
 方式2：threadObj.interrupt()是告诉当前线程可以停止了，至于什么时候结束要看自己。可用threadObj.isInterrupt()判断是否停止。
 方式3：一般线程里的任务都是用循环，如while，此时使用标志位方式是属于最优雅的方式，让线程自然停止。

*threadObj.interrupt()内部原理是设置一个中断标志（假设为flage）以供线程内部判断此标志，如果在当前线程执行Thread.interrupted()则会将flage重置为false

*java中用native关键字标志的方法其实就是用java调用c写的一些api函数。C#也有类似的语法

*进程和线程的区别 详见博客园收藏《说说进程和线程的区别》 https://www.cnblogs.com/zhehan54/p/6130030.html
 *进程是资源分配的最小单位，线程是程序执行的最小单位。如IO、CPU、地址空间等资源。
 *线程是共享进程中的数据的，使用相同的地址空间，因此CPU切换一个线程的花费远比进程要小很多，同时创建一个线程的开销也比进程要小很多。
 *线程之间的通信更方便，同一进程下的线程共享全局变量、静态变量等数据，而进程之间的通信需要以通信的方式（IPC)进行。不过如何处理好同步与互斥是编写多线程程序的难点。
 *但是多进程程序更健壮，多线程程序只要有一个线程死掉，整个进程也死掉了，而一个进程死掉并不会对另外一个进程造成影响，因为进程有自己独立的地址空间。
 
*线程的可见性、原子性、有序性（详见博客园收藏《Java中Volatile关键字详解》https://www.cnblogs.com/zhengbin/p/5654805.html）
 可见性：一个公共变量在多个线程中是可见的，表现是当这个变量在一个线程中的修改对于其它线程是能"同时看到"
 原子性：一个公共的变量的修改，如count++; 是作为一个整体不可分割。（一般count=0是原子的而count+即count=count+1;是非原子的），多个线程同时计算不会造成最后结果"误差"
 有序性：对于公共变量的修改，如count1++;count2++;这段代码在多线程环境下，指令重排，可能造成先执行count2++;再执行count1++;
         有序性的经典案例就是abxy案例，详见咕泡文档或自己的练习。乱序问题也是看咕泡文档。
 *可见性关心的是自己的变化能否立马被其它线程感知，原子性关心的是多个代码指令是否作为一个整体执行，有序性关心的是多个代码指令是否按顺序执行。

*其实乱序问题


*总的来说就是cpu的指令重排\高速缓存问题造成了多线程的可见性、原子性、有序性问题

*单核CPU时代，是不会出现缓存一致性问题，多核CPU情况下就会出现真正的指令并行执行，此时共享数据的处理在并行下就会有缓存一致性、有序性问题

*JMM内存模型提供的相关api用以解决可见性、原子性、有序性问题：
 *volatile阻止了指令重排和高速缓存，保证可见性、有序性但不保证原子性，能保证count=0;安全，但不保证count++;安全。count++;是可分割的，是非原子操作。
         内存屏障，只有一个cup核心时并不需要内存屏障。指令重排时不会将指令重排到内存屏障之前的位置。
	 volatile修饰的变量与普通变量几乎相同，但性能较慢，因为他要在本地代码中差多许多内存屏障来保证执行重排造成的乱序。
 *synchronized只允许同时只有一个线程可操作，可以保证原子性和可见性、有序性，其实就是让count++;或者一些代码块在多线程下是串行执行的。 使用了同步锁机制
 *final可以保证可见性
 *juc

*JUC包是用于解决多线程编程方面的问题的，其下的体系详见博客园收藏《Java并发：多线程和java.util.concurrent并发包总结》


*CPU和内存之间有一个叫高速缓存的东西。这个需要了解
 高速缓存分为L1、L2、L3。它缓存了内存的一些东西，如count=1;
 每一个CPU核心都有一组高速缓存，每组高速缓存之间的内容是相互不可见。如果把count=1;加载到每组高速缓存，当有个CPU改了count值，
 此时只有自己的高速缓存值改变了，其它CPU的高速缓存值没有改变。
 高速缓存的一致性导致了线程的可见性。

*sychronized锁的优化补充学习详见博客园收藏《Java并发编程：Synchronized底层优化（偏向锁、轻量级锁）》

*线程锁之Lock，详见博客园收藏《Java并发编程：Lock》，此文章很好，还涉及读写锁等知识点
  *Lock只是一个接口，java中唯一的实现是ReentrantLock。
   注意Lock只有少量方法供使用，ReentrantLock提供了isFair、isLocked、isHeldByCurrentThread、hasQueuedThreads等实用方法
  *Lock接口有3个获取锁的方法，当多个线程同时（一定要保证同时）获取锁时，3者表现各不一样：
    *lock.lock() 未获取到锁的线程会选择等待
    *lock.tryLock() 未获取到锁的线程可以选择放弃或做其它操作
    *lock.lockInterruptibly() 未获取到锁的线程会等待，但该线程可用thread1.interrupt()终止等待，
                              必须在线程调用lockInterruptibly()的方法上声明异常而不是try-catch。
                              而终止等待后的操作可以在捕获上述异常的地方进行处理。
  *ReadWriteLock接口，juc中唯一实现类是ReentrantReadWriteLock
   *注意reentrantReadWriteLock实例的readLock()和writeLock()方法获取的是单例的lock
   *写锁是排他锁，而读锁是共享锁
  *Condition的使用 详见博客园收藏《Java多线程系列--“JUC锁”06之 Condition条件》和咕泡练习

*CountDownLatch用于制造指定个数的线程并发
*Semaphore用于限流，限制指定个数的线程进行访问。

*AtomicXX类的使用详见简书收藏《Java中atomic包中的原子操作类总结》，注意其中描述的ABA问题

*CAS概念（Compare-and-Swap 比较和交换）与平台相关，它有三个操作数，内存位置值（V），旧的预期值（A），新值（B）。其实就是乐观锁的概念

*for(;;){}和while(true){}的区别
 两者在一般的编译器编译后会进行优化，而优化后的字节码是相同的
 但是如果有一些编译器没有优化，则会会有一些差异for的字节码会更少

*TimeUnit是juc提供的一个工具枚举类

*AQS（AbstractQueuedSynchronizer）在谈到ReentrantLock涉及到AQS概念

？学习阻塞队列LinkedBlockingQueue的使用

  复习zookeeper实现锁的demo
  协程概念的学习


--------------------并发编程 end--------------------------------

*类图中的关系连接符
 —> 关联关系
 --> 依赖关系
 —▷ 继承关系
 --▷ 实现关系
 —◇聚合关系
 —◆复合关系

*源码阅读技巧：
 *用intellij的Structure面板可以分类查看属性、构造函数、继承的东西
 *看该类名称、接口规定“技能”，抽象父类规定“实现流程”。
 *职责单一，公共的逻辑放父类
 *利用装饰器模式、工厂等模式可以对对象的行为进行监控、拦截扩展等操作。

*调试技巧：
 debug时候，console输出的错误信息从上到下是对应最底层到最上层的代码。此时可在throw异常的地方前断点查看引发异常的原因。
 对于第三方框架来说，如果不了解底层的一些逻辑原理的话，很难判断是上层应用的什么错误代码导致了底层异常。所以需要学习底层框架原理。

*@FunctionalInterface表明这个接口将是一个函数式接口，里面只能有一个抽象方法
 注意jdk8提供的Function、Predicate、Consumer、Supplier接口都带有@FunctionalInterface注解
 注意：以下方法参数handlerSupplier是可以传递一个MessageHandler对象或者Supplier<MessageHandler>接口实例
       即可以传MessageHandler实例又可以传递一个返回MessageHandler类型实例的方法或lamda
    public void register(Supplier<MessageHandler> handlerSupplier) { //do sth }

*【597简历的求职意向-->搜索简历 】 功能的解决方案：
 需求：每份简历可以添加3个求职意向，而且每个求职意向有：城市、职位、...等5个条件
       比如A简历有3个求职意向：北京+PHP...、杭州+Java...、厦门+DotNet...
           B简历有3个求职意向：北京+DotNet...、杭州+PHP...、厦门+Java...       
       此时搜索引擎搜索就必须满足搜索"北京" 能匹配到AB，搜索"北京PHP"只能匹配到A，等等等等多种情况。
 ?要问下张阳，这些搜索关键词是通过 选择控件选择出来还是 输入关键词
 

*大多数框架都是支持spring和api两种调用方式，而常用spring方式，为了更好了理解spring方式的相关配置，可以学习使用api方式。

*java经常用接口来规定调用，而用Abstract类来规定该接口实现的一些模板，具体实现类负责其中的一些实现

*在研究源码的时候可以最好调试，通过断点去查看接口接收的实例到底是什么，再去具体实例的实现类或其父类中去查看对应的方法。

*oom异常,内存溢出

*TPS 即每秒处理的事务数，很关键的指标，脚本定义什么事务，就按什么事务来计算。

*幂等函数，或幂等方法，是指可以使用相同参数重复执行，并能获得相同结果的函数。这些函数不会影响系统状态，也不用担心重复执行会对系统造成改变。例如，“getUsername()
*幂等，简单来说：重复调用多次产生的业务结果与调用一次产生的业务结果相同。分布式事务解决方案课中有描述

*到时候准备面试时，是否考虑到福州进行练手面试，缺乏大型互联网项目实战是一个很大的坎。


*有时间的话，到后面可以按章节刷刷咕泡的问题论坛和qq群。

*整合淘淘和jeesite形成自己的框架。

*后期如果有需要用大量的数据做压力测试，可以找郭总或者找咕泡老师

*职业方向：把业务功能做熟悉，再研究分布式重构。



？？分布式环境下的事务处理、服务调用链出错等问题。这些必须进行系统深入的学习
？？字节码重组，动态编译技术是否要深入的学习
？？底层通信、多线程和并发要进行系统学习
？org.projectlombok的使用

*神州优车
 一般13薪，有kpi，框架集成，如果只是普通业务开发，是否考虑。
 不同级别能看到的框架源码不一样

*面试宝典https://www.docin.com/p-2122232700.html、
 https://blog.csdn.net/weixin_42248137/article/details/80395227、
 https://www.cnblogs.com/xueSpring/p/8026875.html
 阿里面试题：https://gper.gupaoedu.com/answers/712

*面试之前将一些知识文档全部打印进行复习。当做一次考试。    
*今天面试碰到面试官问秒杀 我说用redis list结构push方法解决秒杀 他说10000个人进来会导致连接超时或者连接满拒绝吗？ 

*整理实战项目：
 海晟相关系统
 质量检测系统，主要是设计模式应用
 MytotalWorld电商平台，结合淘淘系统
 大白抢单中间件，伪销售抢单
 
     